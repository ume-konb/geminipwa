<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeminiPWA</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" id="theme-color-meta" content="#4a90e2">
    <style>
        /* --- CSS変数 --- */
        :root {
            /* ライトモード (デフォルト) */
            --bg-primary: #ffffff;
            --bg-secondary: #f0f2f5;
            --bg-tertiary: #fdfdfd;
            --bg-input: #ffffff;
            --bg-user-message: #dcf8c6;
            --bg-model-message: #e5e5ea;
            --bg-system-message: #f0f8ff; /* システムプロンプト用 */
            --bg-error-message: #ffebee;
            --bg-button: #4a90e2;
            --bg-button-hover: #357abd;
            --bg-button-disabled: #a0c3e8;
            --bg-button-action: #777777;
            --bg-button-action-hover: #555555;
            --bg-button-delete: #e53935;
            --bg-button-delete-hover: #c62828;
            --bg-button-retry: #43a047;
            --bg-button-retry-hover: #2e7d32;
            --bg-button-edit: #ff9800;
            --bg-button-edit-hover: #f57c00;
            --bg-button-duplicate: #546e7a;
            --bg-button-duplicate-hover: #37474f;
            --bg-button-export: #1e88e5;
            --bg-button-export-hover: #1565c0;
            --bg-button-save: #30d158;
            --bg-button-save-hover: #24a345;
            --bg-button-cancel: #f44336;
            --bg-button-cancel-hover: #d32f2f;
            --bg-button-update: #1976d2;
            --bg-button-update-hover: #115293;
            --bg-header: #4a90e2;
            --bg-message-actions: rgba(255, 255, 255, 0.8);
            --bg-overlay-light: rgba(255, 255, 255, 0.65); /* ライトモード用オーバーレイ */
            /* カスケードコントロール用 */
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);

            --text-primary: #333333;
            --text-secondary: #777777;
            --text-light: #ffffff;
            --text-disabled: #e0e0e0;
            --text-error: #c62828;
            --text-link: #4a90e2;
            --text-placeholder: #999999;
            --text-system: #555; /* システムプロンプト用 */

            --border-primary: #cccccc;
            --border-secondary: #dddddd;
            --border-tertiary: #eeeeee;
            --border-danger: #ffcdd2;
            --border-system: #add8e6; /* システムプロンプト用 */

            --shadow-primary: rgba(0, 0, 0, 0.1);
            --shadow-secondary: rgba(0,0,0,0.1);

            --message-max-width: 85%;

            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;

            --chat-background-image: none; /* チャット背景画像 (デフォルトなし) */
        }

        body.dark-mode {
            /* ダークモード時の上書き */
            --bg-primary: #1a1a1a;
            --bg-secondary: #101010;
            --bg-tertiary: #252525;
            --bg-input: #303030;
            --bg-user-message: #056162;
            --bg-model-message: #3a3a3c;
            --bg-system-message: #2a3a4a; /* システムプロンプト用 */
            --bg-error-message: #5c1c1c;
            --bg-button: #007aff;
            --bg-button-hover: #005ecb;
            --bg-button-disabled: #4a5a70;
            --bg-button-action: #666666;
            --bg-button-action-hover: #888888;
            --bg-button-delete: #ff3b30;
            --bg-button-delete-hover: #d12c23;
            --bg-button-retry: #34c759;
            --bg-button-retry-hover: #249a41;
            --bg-button-edit: #ff9500;
            --bg-button-edit-hover: #d17d00;
            --bg-button-duplicate: #8e8e93;
            --bg-button-duplicate-hover: #6b6b70;
            --bg-button-export: #0a84ff;
            --bg-button-export-hover: #0069d1;
            --bg-button-save: #30d158;
            --bg-button-save-hover: #24a345;
            --bg-button-cancel: #ff453a;
            --bg-button-cancel-hover: #d1332b;
            --bg-button-update: #0a84ff;
            --bg-button-update-hover: #0069d1;
            --bg-header: #007aff;
            --bg-message-actions: rgba(50, 50, 50, 0.8);
            --bg-overlay-dark: rgba(30, 30, 30, 0.55); /* ダークモード用オーバーレイ */
            /* カスケードコントロール用 (ダーク) */
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);

            --text-primary: #e0e0e0;
            --text-secondary: #aaaaaa;
            --text-light: #ffffff;
            --text-disabled: #666666;
            --text-error: #ff8a80;
            --text-link: #00aaff;
            --text-placeholder: #777777;
            --text-system: #ccc; /* システムプロンプト用 */

            --border-primary: #444444;
            --border-secondary: #555555;
            --border-tertiary: #333333;
            --border-danger: #7a2e35;
            --border-system: #4682b4; /* システムプロンプト用 */

            --shadow-primary: rgba(255, 255, 255, 0.1);
            --shadow-secondary: rgba(0, 0, 0, 0.5);
        }

        /* --- リセットと基本スタイル --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html, body {
            height: 100%;
            font-family: var(--font-family);
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            overscroll-behavior-y: contain; /* iOSでの過剰なスクロールを抑制 */
            transition: background-color 0.3s ease, color 0.3s ease;
            overflow: hidden; /* bodyでのスクロールを禁止 */
        }
        button {
            cursor: pointer;
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            font-size: 14px;
            background-color: var(--bg-button);
            color: var(--text-light);
            transition: background-color 0.2s ease, color 0.2s ease;
            line-height: 1.4;
        }
        button:hover:not(:disabled) {
            background-color: var(--bg-button-hover);
        }
        button:disabled {
            background-color: var(--bg-button-disabled);
            cursor: not-allowed;
            color: var(--text-disabled);
        }
        input[type="text"],
        input[type="password"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-primary);
            border-radius: 5px;
            font-size: 14px;
            margin-bottom: 10px;
            background-color: var(--bg-input);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
        }
        textarea {
            min-height: 80px;
            resize: vertical;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 14px;
            color: var(--text-primary);
        }
        ::placeholder { color: var(--text-placeholder); opacity: 1; }
        :-ms-input-placeholder { color: var(--text-placeholder); }
        ::-ms-input-placeholder { color: var(--text-placeholder); }
        .hidden { display: none !important; }

        /* --- アプリ構造 --- */
        .app-container {
            display: flex; /* 子要素(.screen)を配置するため */
            position: relative; /* 子要素のabsolute配置の基準 */
            height: 100%;
            max-width: 800px;
            margin: 0 auto;
            background-color: var(--bg-primary);
            box-shadow: 0 0 10px var(--shadow-secondary);
            overflow: hidden; /* スワイプアニメーションのため */
            transition: background-color 0.3s ease;
        }

        /* --- ヘッダー --- */
        .app-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            background-color: var(--bg-header);
            color: var(--text-light);
            flex-shrink: 0;
            position: sticky; /* 画面上部に固定 */
            top: 0;
            z-index: 10; /* コンテンツより手前 */
            transition: background-color 0.3s ease;
            gap: 10px;
        }
        .app-header h1 {
            font-size: 18px;
            font-weight: bold;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            text-align: left;
            margin: 0;
            margin-right: auto; /* 後続要素を右に寄せる */
        }
        .header-button {
            background: none;
            border: none;
            color: var(--text-light);
            font-size: 20px;
            padding: 5px;
            line-height: 1;
            min-width: 30px;
            flex-shrink: 0;
        }
        /* 履歴画面ヘッダーのレイアウト調整 */
        #history-screen .app-header {
            flex-direction: row-reverse; /* 右から配置: [戻る] [タイトル] [インポート] */
            justify-content: flex-start; /* 左寄せにする */
        }
        #history-screen .app-header h1#history-title {
            margin-right: 0;
            margin-left: auto;
            text-align: right;
        }
        #history-screen .app-header #back-to-chat-from-history {
            order: 1; /* 戻るボタンを一番右に */
        }
        #history-screen .app-header #history-title {
            order: 2; /* タイトルを中央に */
        }
        #history-screen .app-header #import-history-btn {
            order: 3; /* インポートボタンを一番左に */
            margin-right: 0; /* 右マージン削除 */
        }

        .header-save-button {
            padding: 4px 12px;
            font-size: 13px;
            background-color: var(--bg-button-save);
            color: var(--text-light);
            border-radius: 5px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
            flex-shrink: 0;
        }
        .header-save-button:hover:not(:disabled) {
            background-color: var(--bg-button-save-hover);
        }
        body.dark-mode .header-save-button {
             background-color: var(--bg-button-save);
        }
        body.dark-mode .header-save-button:hover:not(:disabled) {
             background-color: var(--bg-button-save-hover);
        }
        .header-notice {
            font-size: 11px;
            font-weight: normal;
            color: rgba(255, 255, 255, 0.8);
            text-align: right;
            white-space: nowrap;
            flex-shrink: 0;
        }
        body.dark-mode .header-notice {
            color: rgba(255, 255, 255, 0.7);
        }
        .new-chat-button {
            font-size: 14px;
            padding: 5px 10px;
            background-color: var(--bg-button-save);
            color: var(--text-light);
            flex-shrink: 0;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        .new-chat-button:hover {
            background-color: var(--bg-button-save-hover);
        }
        body.dark-mode .new-chat-button {
            background-color: var(--bg-button-save);
        }
        body.dark-mode .new-chat-button:hover {
            background-color: var(--bg-button-save-hover);
        }

        /* --- メインコンテンツエリア --- */
        .main-content {
            flex-grow: 1;
            overflow-y: auto; /* デフォルトは縦スクロール */
            padding: 15px;
            position: relative; /* 必要に応じて内部要素の配置基準に */
            z-index: 1; /* オーバーレイより手前 */
            touch-action: pan-y; /* デフォルトは縦方向のパン操作を許可 */
        }

        /* --- 画面共通スタイル (スワイプアニメーション用) --- */
        .screen {
            position: absolute; /* スワイプアニメーションのため */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease-in-out; /* スワイプアニメーション */
            background-color: var(--bg-primary); /* デフォルト背景 */
            z-index: 0; /* 非アクティブ画面は背面に */
        }
        .screen.active {
            transform: translateX(0);
            z-index: 1; /* アクティブ画面を最前面に */
        }
        /* 初期位置と非表示時の位置 (修正後) */
        #chat-screen { transform: translateX(0); }
        #history-screen { transform: translateX(-100%); } /* 左に配置 */
        #settings-screen { transform: translateX(100%); } /* 右に配置 */


        /* --- チャット画面 --- */
        #chat-screen {
            position: relative; /* 疑似要素のため */
            z-index: 0; /* ベースレイヤー */
            background-image: var(--chat-background-image);
            background-size: cover;
            background-position: center center;
            background-repeat: no-repeat;
            transition: background-image 0.3s ease, transform 0.3s ease-in-out;
        }

        /* チャット画面用オーバーレイ */
        #chat-screen::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--bg-overlay-light); /* CSS変数を使用 */
            z-index: 0; /* コンテンツの後ろ、背景画像の前 */
            transition: background-color 0.3s ease;
            pointer-events: none; /* クリックを透過させる */
        }
        /* ダークモード用オーバーレイ */
        body.dark-mode #chat-screen::before {
            background-color: var(--bg-overlay-dark);
        }

        #chat-screen .main-content {
            padding-bottom: 80px; /* 入力エリアのスペース */
            z-index: 1; /* チャットコンテンツをオーバーレイより手前に */
            background-color: transparent; /* オーバーレイ/背景画像が見えるように */
            /* overflow-y: auto; を overflow: auto; に変更して水平スクロールも可能に */
            overflow: auto;
            touch-action: pan-x pan-y pinch-zoom; /* 水平・垂直パン・ピンチズームを許可 */
        }
        /* ヘッダーとフッターはオーバーレイより手前 */
        #chat-screen .app-header { z-index: 2; }
        #chat-screen .chat-input-area {
            z-index: 2;
            background-color: var(--bg-secondary); /* 入力エリアの背景は不透明 */
        }
        /* 履歴画面と設定画面のメインコンテンツでピンチズームを抑制 */
        #history-screen .main-content,
        #settings-screen .main-content {
            touch-action: pan-y; /* 縦スクロールのみ許可 */
        }


        /* --- システムプロンプト表示エリア --- */
        .system-prompt-area {
            padding: 10px 15px;
            margin-bottom: 15px;
            border: 1px solid var(--border-system);
            border-radius: 8px;
            background-color: var(--bg-system-message);
            color: var(--text-system);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, opacity 0.3s ease, visibility 0.3s ease, max-height 0.3s ease; /* transition追加 */
            position: relative;
            z-index: 1; /* メッセージより手前 */
            overflow: hidden; /* hiddenクラスでのアニメーション用 */
            max-height: 500px; /* 通常時の最大高さ (アニメーション用) */
        }
        .system-prompt-area.hidden {
            padding-top: 0;
            padding-bottom: 0;
            margin-bottom: 0;
            border-width: 0;
            max-height: 0; /* 非表示時の高さ */
            opacity: 0;
            visibility: hidden;
        }
        .system-prompt-area details {
            width: 100%;
        }
        .system-prompt-area summary {
            font-weight: bold;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-primary); /* summaryは通常テキスト色 */
            list-style: none; /* マーカーを消す */
            display: flex;
            align-items: center;
            justify-content: space-between;
            user-select: none; /* テキスト選択不可 */
            -webkit-user-select: none; /* Safari用 */
            -moz-user-select: none; /* Firefox用 */
            -ms-user-select: none; /* IE/Edge用 */
            outline: none; /* フォーカス時のアウトラインを消す */
            -webkit-tap-highlight-color: transparent; /* モバイルタップ時のハイライトを消す */
        }
        .system-prompt-area summary::-webkit-details-marker { display: none; } /* Chrome/Safari */
        .system-prompt-area summary::marker { display: none; } /* Firefox */
        .system-prompt-area summary::after {
            content: '▼'; /* 閉じた状態のアイコン */
            font-size: 10px;
            margin-left: 5px;
            transition: transform 0.2s ease;
        }
        .system-prompt-area details[open] summary::after {
            transform: rotate(180deg); /* 開いた状態のアイコン */
        }
        .system-prompt-content {
            margin-top: 10px;
        }
        .system-prompt-content textarea {
            width: 100%;
            min-height: 60px;
            max-height: 200px; /* 最大高さを設定 */
            margin-bottom: 8px;
            font-size: 13px;
            background-color: var(--bg-input);
            color: var(--text-primary);
            border-color: var(--border-primary);
        }
        .system-prompt-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }
        .system-prompt-actions button {
            padding: 4px 10px;
            font-size: 12px;
        }
        .system-prompt-actions .save-system-prompt-btn { background-color: var(--bg-button-save); }
        .system-prompt-actions .save-system-prompt-btn:hover { background-color: var(--bg-button-save-hover); }
        .system-prompt-actions .cancel-system-prompt-btn { background-color: var(--bg-button-cancel); }
        .system-prompt-actions .cancel-system-prompt-btn:hover { background-color: var(--bg-button-cancel-hover); }
        /* ------------------------------------ */

        .message-container {
            display: flex;
            flex-direction: column;
            /* gap: 35px; */ /* gapを削除し、messageのmarginで調整 */
            position: relative;
            z-index: 1; /* メッセージをオーバーレイより手前に */
        }
        .message {
            padding: 10px 15px;
            border-radius: 15px;
            max-width: var(--message-max-width);
            min-width: 30%;
            min-height: 40px;
            position: relative;
            word-wrap: break-word;
            /* margin-bottom: 35px; */ /* 下ボタン用スペース */
            margin-top: 35px; /* 上ボタン用スペース */
            margin-bottom: 35px; /* 下ボタン用スペース */
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
            z-index: 1; /* メッセージバブル自体を手前に */
            box-shadow: 0 1px 2px var(--shadow-primary); /* 視認性向上のための影 */
        }
        /* 最初のメッセージの上マージンは不要 */
        .message:first-child {
            margin-top: 0;
        }
        .message pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: inherit;
            font-size: 14px;
            margin: 0;
            color: inherit;
            transition: opacity 0.2s ease;
        }
        .message.user {
            background-color: var(--bg-user-message);
            align-self: flex-end;
            border-bottom-right-radius: 5px;
            body:not(.dark-mode) & { color: #333; }
            body.dark-mode & { color: #e0e0e0; }
        }
        .message.model {
            background-color: var(--bg-model-message);
            align-self: flex-start;
            border-bottom-left-radius: 5px;
            max-width: 90%;
        }
        .message.error {
            background-color: var(--bg-error-message);
            color: var(--text-error);
            align-self: flex-start;
            border-bottom-left-radius: 5px;
            margin-top: 10px; /* エラーメッセージのマージン調整 */
            margin-bottom: 10px;
        }

        /* メッセージアクション (ホバーボタン - 下) */
        .message-actions {
            position: absolute;
            bottom: -35px; /* 下に配置 */
            display: none; /* ホバーで表示 */
            flex-wrap: nowrap;
            gap: 5px;
            background: var(--bg-message-actions);
            /* padding: 5px 8px; */ /* 元のpadding */
            padding: 10px 8px 5px 8px; /* 上方向のホバー領域を増やす (top, right, bottom, left) */
            border-radius: 5px;
            box-shadow: 0 1px 3px var(--shadow-primary);
            z-index: 2; /* アクションをメッセージバブルより手前に */
            transition: opacity 0.2s ease, background-color 0.3s ease;
        }
        .message:hover .message-actions {
            display: flex;
        }
        .message.user .message-actions {
            right: 0;
            left: auto;
            justify-content: flex-end;
        }
        .message.model .message-actions {
            left: 0;
            right: auto;
            justify-content: flex-start;
        }
        .message-actions button {
            background-color: var(--bg-button-action);
            color: var(--text-light);
            padding: 4px 10px;
            font-size: 12px;
            border-radius: 4px;
            white-space: nowrap;
            line-height: 1.5;
        }
        .message-actions button:hover {
            background-color: var(--bg-button-action-hover);
        }
        .message-actions .js-edit-btn { background-color: var(--bg-button-edit); }
        .message-actions .js-edit-btn:hover { background-color: var(--bg-button-edit-hover); }
        .message-actions .js-delete-btn { background-color: var(--bg-button-delete); }
        .message-actions .js-delete-btn:hover { background-color: var(--bg-button-delete-hover); }
        .message-actions .js-retry-btn { background-color: var(--bg-button-retry); }
        .message-actions .js-retry-btn:hover { background-color: var(--bg-button-retry-hover); }

        /* カスケードコントロール (ホバーボタン - 上) */
        .message-cascade-controls {
            position: absolute;
            top: -35px; /* 上に配置 */
            left: 0;
            display: none; /* ホバーで表示 */
            align-items: center;
            flex-wrap: nowrap;
            gap: 5px;
            background: var(--bg-message-actions);
            /* padding: 5px 8px; */ /* 元のpadding */
            padding: 5px 8px 10px 8px; /* 下方向のホバー領域を増やす (top, right, bottom, left) */
            border-radius: 5px;
            box-shadow: 0 -1px 3px var(--shadow-primary); /* 上方向の影 */
            z-index: 2;
            transition: opacity 0.2s ease, background-color 0.3s ease;
        }
        .message.model:hover .message-cascade-controls {
            display: flex;
        }
        .message-cascade-controls button {
            background-color: var(--bg-cascade-button);
            color: var(--text-light);
            padding: 4px 8px; /* 少し小さめ */
            font-size: 14px; /* アイコン想定 */
            border-radius: 4px;
            line-height: 1;
            min-width: 25px;
        }
        .message-cascade-controls button:hover:not(:disabled) {
            background-color: var(--bg-cascade-button-hover);
        }
        .message-cascade-controls button:disabled {
            background-color: var(--bg-button-disabled);
            cursor: not-allowed;
            opacity: 0.5;
        }
        .message-cascade-controls .cascade-indicator {
            font-size: 11px;
            color: var(--text-cascade-indicator);
            padding: 0 5px;
            white-space: nowrap;
            font-weight: 500;
        }
        .message-cascade-controls .cascade-delete-btn {
            background-color: var(--bg-cascade-delete-button);
            margin-left: 5px; /* 削除ボタンを少し離す */
        }
        .message-cascade-controls .cascade-delete-btn:hover {
            background-color: var(--bg-cascade-delete-button-hover);
        }

        /* インライン編集スタイル */
        .message.editing pre {
            opacity: 0;
            height: 0;
            overflow: hidden;
            pointer-events: none;
        }
        .message.editing .message-actions,
        .message.editing .message-cascade-controls { /* 編集中は上下のコントロールも非表示 */
             opacity: 0;
             pointer-events: none;
             display: none !important; /* 確実に非表示 */
        }
        .message-edit-area {
            margin-top: 5px;
        }
        .message-edit-area textarea {
            min-height: 60px;
            margin-bottom: 5px;
            width: 100%; /* 幅を親要素に合わせる */
        }
        .message-edit-actions {
            display: flex;
            justify-content: flex-end;
            gap: 8px;
            margin-top: 5px;
        }
        .message-edit-actions button {
            padding: 4px 10px;
            font-size: 12px;
        }
        .message-edit-actions .save-edit-btn { background-color: var(--bg-button-save); }
        .message-edit-actions .save-edit-btn:hover { background-color: var(--bg-button-save-hover); }
        .message-edit-actions .cancel-edit-btn { background-color: var(--bg-button-cancel); }
        .message-edit-actions .cancel-edit-btn:hover { background-color: var(--bg-button-cancel-hover); }

        /* チャット入力エリア */
        .chat-input-area {
            display: flex;
            align-items: flex-end;
            padding: 10px 15px;
            border-top: 1px solid var(--border-primary);
            /* background-color は #chat-screen セレクタで指定 */
            flex-shrink: 0;
            position: fixed; /* 画面下部に固定 */
            bottom: 0;
            left: 0;
            right: 0;
            max-width: 800px; /* app-container と同じ幅 */
            margin: 0 auto;
            box-sizing: border-box;
            /* z-index は #chat-screen セレクタで指定 */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .chat-input-area textarea {
            flex-grow: 1;
            min-height: 40px;
            max-height: 120px;
            height: 40px;
            resize: none;
            margin-right: 10px;
            margin-bottom: 0;
            padding: 8px 10px;
            overflow-y: auto;
        }
        .chat-input-area button#send-button {
            height: 40px;
            width: 40px;
            padding: 0;
            font-size: 18px;
            font-weight: bold;
            flex-shrink: 0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .chat-input-area button#send-button.sending {
            background-color: #ffc107;
            color: #333;
        }
        .chat-input-area button#send-button.sending:hover {
            background-color: #ffa000;
        }
        body.dark-mode .chat-input-area button#send-button.sending {
            background-color: #ffd60a;
            color: #1a1a1a;
        }
        body.dark-mode .chat-input-area button#send-button.sending:hover {
            background-color: #ffca28;
        }

        /* ローディングインジケーター */
        #loading-indicator {
            position: fixed; /* 画面に固定 */
            bottom: 65px;    /* 入力エリアの上あたり (入力エリア高さ約40px + パディング10px*2 + 余白5px) */
            right: 20px;     /* 右端からの距離 */
            background-color: var(--bg-tertiary); /* 背景色 */
            color: var(--text-secondary);      /* テキスト色 */
            padding: 6px 12px; /* パディング調整 */
            border-radius: 15px; /* より丸みのある角 */
            font-size: 11px; /* フォントサイズ調整 */
            font-style: normal; /* イタリック解除 */
            font-weight: 500;
            z-index: 3;      /* 入力エリア(z-index: 2)より手前 */
            box-shadow: 0 2px 5px var(--shadow-primary); /* 少し目立つ影 */
            /* フェードイン/アウトのためのトランジション */
            transition: opacity 0.3s ease, transform 0.3s ease, visibility 0.3s ease;
            opacity: 0; /* 初期状態は非表示 (透明) */
            visibility: hidden; /* 初期状態は非表示 (レイアウトに影響しない) */
            transform: translateY(10px); /* 少し下から登場するアニメーション */
            pointer-events: none; /* クリックを透過 */
        }
        /* hiddenクラスがついていない場合に表示 */
        #loading-indicator:not(.hidden) {
            opacity: 1;
            visibility: visible;
            transform: translateY(0); /* 元の位置に戻る */
        }

        /* ダークモード固有のスタイル（必要に応じて微調整） */
        body.dark-mode #loading-indicator {
            background-color: var(--bg-input); /* ダークモードでは入力欄に近い背景色 */
            color: var(--text-secondary);
            box-shadow: 0 2px 6px var(--shadow-secondary);
        }

        /* --- 履歴画面 --- */
        /* 履歴画面自体は背景画像なし */
        #history-screen {
             background-color: var(--bg-primary); /* 自身の背景色を確保 */
             transition: transform 0.3s ease-in-out; /* スワイプアニメーション */
        }
        #history-screen .main-content {
             background-color: transparent; /* screenの背景色が見えるように */
             /* touch-action: pan-y; */ /* 上部で指定済み */
        }

        .history-list {
            list-style: none;
            padding: 0;
        }
        .history-item {
            padding: 12px;
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            margin-bottom: 10px;
            background-color: var(--bg-primary);
            transition: background-color 0.2s ease, border-color 0.3s ease;
            cursor: pointer;
        }
        .history-item:hover {
            background-color: var(--bg-tertiary);
        }
        .history-item-details {
            overflow: hidden;
            min-width: 0;
            width: 100%;
            margin-bottom: 8px;
        }
        .history-item-title {
            font-size: 15px;
            font-weight: bold;
            margin-bottom: 0px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            display: block;
            color: var(--text-primary);
        }
        .history-item-bottom-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }
        .history-item-dates {
            font-size: 9px;
            color: var(--text-secondary);
            flex-shrink: 0;
            line-height: 1.3;
            text-align: left;
        }
        .history-item-dates span {
            display: block;
            white-space: nowrap;
        }
        .history-item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
            flex-wrap: nowrap;
            cursor: default; /* ボタン以外はクリックを透過 */
        }
        .history-item-actions button {
             cursor: pointer;
        }
        .history-item-actions .js-edit-title-btn {
            background-color: var(--bg-button-edit);
            font-size: 16px;
            padding: 6px 8px;
        }
        .history-item-actions .js-edit-title-btn:hover { background-color: var(--bg-button-edit-hover); }
        .history-item-actions .js-delete-btn { background-color: var(--bg-button-delete); }
        .history-item-actions .js-delete-btn:hover { background-color: var(--bg-button-delete-hover); }
        .history-item-actions .js-duplicate-btn { background-color: var(--bg-button-duplicate); }
        .history-item-actions .js-duplicate-btn:hover { background-color: var(--bg-button-duplicate-hover); }
        .history-item-actions .js-export-btn { background-color: var(--bg-button-export); }
        .history-item-actions .js-export-btn:hover { background-color: var(--bg-button-export-hover); }

        .js-history-item-template {
             display: none !important; /* テンプレートは非表示 */
        }
        #no-history-message {
            text-align: center;
            color: var(--text-secondary);
            margin-top: 20px;
        }

        /* --- 設定画面 --- */
        /* 設定画面自体は背景画像なし */
        #settings-screen {
             background-color: var(--bg-primary); /* 自身の背景色を確保 */
             transition: transform 0.3s ease-in-out; /* スワイプアニメーション */
        }
         #settings-screen .main-content {
             background-color: transparent; /* screenの背景色が見えるように */
             /* touch-action: pan-y; */ /* 上部で指定済み */
        }

        .settings-group {
            margin-bottom: 25px;
            padding: 15px;
            border: 1px solid var(--border-tertiary);
            border-radius: 8px;
            background-color: var(--bg-tertiary);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        .settings-group h3 {
            margin-bottom: 15px;
            font-size: 16px;
            color: var(--text-link);
            border-bottom: 1px solid var(--border-tertiary);
            padding-bottom: 5px;
            transition: color 0.3s ease, border-color 0.3s ease;
        }
        .settings-actions {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-tertiary);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .settings-actions.bottom {
            margin-bottom: 20px;
        }
        .settings-actions button {
            width: 100%;
        }
        .danger-zone {
            margin-top: 30px;
            padding-top: 20px;
            border-top: 2px solid var(--border-danger);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .danger-zone button {
            width: 100%;
        }
        #update-app-btn {
            background-color: var(--bg-button-update);
        }
        #update-app-btn:hover {
            background-color: var(--bg-button-update-hover);
        }
        #clear-data-btn {
            background-color: var(--bg-button-delete);
        }
        #clear-data-btn:hover {
            background-color: var(--bg-button-delete-hover);
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            cursor: pointer;
            color: var(--text-primary);
        }
        .checkbox-label input[type="checkbox"] {
            width: auto;
            margin-bottom: 0;
            cursor: pointer;
        }
        .param-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
        }

        /* 設定画面: 画像コントロール */
        .image-upload-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        /* アクションボタンスタイルをアップロードボタンに適用 */
        .settings-action-button {
            background-color: var(--bg-button-action);
            padding: 8px 15px;
            border-radius: 5px;
            border: none;
            font-size: 14px;
            color: var(--text-light);
            cursor: pointer;
        }
        .settings-action-button:hover {
            background-color: var(--bg-button-action-hover);
        }
        /* 削除ボタンスタイル */
        .settings-delete-button {
            background-color: var(--bg-button-delete);
            padding: 8px 15px; /* 他のボタンと一貫性のあるパディング */
            border-radius: 5px;
            border: none;
            font-size: 14px;
            color: var(--text-light);
            cursor: pointer;
            margin-left: auto; /* 削除ボタンを右端に寄せる */
        }
        .settings-delete-button:hover {
            background-color: var(--bg-button-delete-hover);
        }
        .background-thumbnail {
            max-width: 100px;
            max-height: 60px;
            border-radius: 4px;
            border: 1px solid var(--border-tertiary);
            object-fit: cover;
            vertical-align: middle;
        }
        /* ========================================== */

        /* --- OSのカラースキームを優先 --- */
        @media (prefers-color-scheme: dark) {
          body:not(.light-mode-forced) {
            /* デフォルトでダークモード変数を適用 */
            --bg-primary: #1a1a1a;
            --bg-secondary: #101010;
            --bg-tertiary: #252525;
            --bg-input: #303030;
            --bg-user-message: #056162;
            --bg-model-message: #3a3a3c;
            --bg-system-message: #2a3a4a; /* システムプロンプト用 */
            --bg-error-message: #5c1c1c;
            --bg-button: #007aff;
            --bg-button-hover: #005ecb;
            --bg-button-disabled: #4a5a70;
            --bg-button-action: #666666;
            --bg-button-action-hover: #888888;
            --bg-button-delete: #ff3b30;
            --bg-button-delete-hover: #d12c23;
            --bg-button-retry: #34c759;
            --bg-button-retry-hover: #249a41;
            --bg-button-edit: #ff9500;
            --bg-button-edit-hover: #d17d00;
            --bg-button-duplicate: #8e8e93;
            --bg-button-duplicate-hover: #6b6b70;
            --bg-button-export: #0a84ff;
            --bg-button-export-hover: #0069d1;
            --bg-button-save: #30d158;
            --bg-button-save-hover: #24a345;
            --bg-button-cancel: #ff453a;
            --bg-button-cancel-hover: #d1332b;
            --bg-button-update: #0a84ff;
            --bg-button-update-hover: #0069d1;
            --bg-header: #007aff;
            --bg-message-actions: rgba(50, 50, 50, 0.8);
            /* --bg-overlay-dark は body.dark-mode で定義済み */
            /* カスケードコントロール用 (ダーク) */
            --bg-cascade-button: var(--bg-button-action);
            --bg-cascade-button-hover: var(--bg-button-action-hover);
            --bg-cascade-delete-button: var(--bg-button-delete);
            --bg-cascade-delete-button-hover: var(--bg-button-delete-hover);
            --text-cascade-indicator: var(--text-secondary);

            --text-primary: #e0e0e0;
            --text-secondary: #aaaaaa;
            --text-light: #ffffff;
            --text-disabled: #666666;
            --text-error: #ff8a80;
            --text-link: #00aaff;
            --text-placeholder: #777777;
            --text-system: #ccc; /* システムプロンプト用 */

            --border-primary: #444444;
            --border-secondary: #555555;
            --border-tertiary: #333333;
            --border-danger: #7a2e35;
            --border-system: #4682b4; /* システムプロンプト用 */

            --shadow-primary: rgba(255, 255, 255, 0.1);
            --shadow-secondary: rgba(0, 0, 0, 0.5);
          }
        }

        /* --- Markdown固有スタイル --- */
        .message-content {
            font-size: 14px;
            line-height: 1.6;
            color: inherit;
            word-wrap: break-word;
            overflow-wrap: break-word;
            position: relative; /* コンテンツがメッセージフロー内にあることを保証 */
            z-index: 1; /* オーバーレイより手前 */
        }
        .message-content > *:first-child { margin-top: 0; }
        .message-content > *:last-child { margin-bottom: 0; }
        .message-content h1, .message-content h2, .message-content h3, .message-content h4, .message-content h5, .message-content h6 {
            margin-top: 1.2em;
            margin-bottom: 0.6em;
            font-weight: bold;
            line-height: 1.3;
            color: inherit;
        }
        .message-content h1 { font-size: 1.8em; }
        .message-content h2 { font-size: 1.5em; }
        .message-content h3 { font-size: 1.3em; }
        .message-content h4 { font-size: 1.1em; }
        .message-content p {
            margin-bottom: 0.8em;
        }
        .message-content ul, .message-content ol {
            margin-bottom: 0.8em;
            padding-left: 2em;
        }
        .message-content li {
            margin-bottom: 0.3em;
        }
        .message-content li > ul, .message-content li > ol {
             margin-top: 0.3em;
             margin-bottom: 0.3em;
        }
        .message-content pre {
            background-color: var(--bg-secondary);
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 1em 0;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 13px;
            border: 1px solid var(--border-tertiary);
            color: var(--text-secondary);
        }
        /* ユーザーメッセージの<pre>は背景色透過が必要 */
        .message.user .message-content pre {
             background-color: transparent;
             padding: 0;
             margin: 0;
             border: none;
             border-radius: 0;
             color: inherit;
             font-family: inherit;
             font-size: inherit;
             line-height: inherit;
             white-space: pre-wrap;
             word-wrap: break-word;
             overflow-x: visible;
        }
        .message-content code:not(pre > code) { /* インラインコード */
            background-color: var(--bg-secondary);
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            font-size: 0.9em;
            border: 1px solid var(--border-tertiary);
            color: var(--text-secondary);
        }
        .message-content blockquote {
            margin: 1em 0;
            padding-left: 1em;
            border-left: 4px solid var(--border-primary);
            color: var(--text-secondary);
        }
        .message-content blockquote > *:first-child { margin-top: 0; }
        .message-content blockquote > *:last-child { margin-bottom: 0; }
        .message-content a {
            color: var(--text-link);
            text-decoration: underline;
        }
        .message-content strong {
            font-weight: bold;
        }
        .message-content em {
            font-style: italic;
        }
        .message-content table {
            border-collapse: collapse;
            margin: 1em 0;
            width: auto;
            border: 1px solid var(--border-secondary);
        }
        .message-content th, .message-content td {
            border: 1px solid var(--border-secondary);
            padding: 6px 10px;
            text-align: left;
        }
        .message-content th {
            background-color: var(--bg-tertiary);
            font-weight: bold;
        }
        .message-content hr {
            border: none;
            border-top: 1px solid var(--border-secondary);
            margin: 1.5em 0;
        }

        /* :hover または .show-actions クラスで操作ボックスを表示 */
        .message:hover .message-actions,
        .message.show-actions .message-actions,
        .message:hover .message-cascade-controls,
        .message.show-actions .message-cascade-controls {
            display: flex; /* または block など、元の表示プロパティに合わせる */
            /* 必要であれば他のスタイルも調整 */
        }

        /* 編集中はクリックによる表示も抑制する (既存ルールと合わせる) */
        .message.editing.show-actions .message-actions,
        .message.editing.show-actions .message-cascade-controls {
            display: none !important; /* 編集時は確実に非表示 */
        }
        /* リトライ中の非表示スタイル */
        .message.retrying-hidden {
            display: none !important;
        }
        /* ダークモードでのMarkdown調整 */
        body.dark-mode .message-content pre {
            background-color: var(--bg-tertiary);
            border-color: var(--border-primary);
            color: var(--text-secondary);
        }
         body.dark-mode .message-content code:not(pre > code) {
            background-color: var(--bg-tertiary);
            border-color: var(--border-primary);
            color: var(--text-secondary);
        }
        body.dark-mode .message-content blockquote {
            border-left-color: var(--border-primary);
            color: var(--text-secondary);
        }
         body.dark-mode .message-content a {
            color: var(--text-link);
         }
        body.dark-mode .message-content table,
        body.dark-mode .message-content th,
        body.dark-mode .message-content td {
            border-color: var(--border-primary);
        }
        body.dark-mode .message-content th {
            background-color: var(--bg-secondary);
        }
        body.dark-mode .message-content hr {
            border-top-color: var(--border-primary);
        }

        /* --- カスタムダイアログスタイル --- */
        .custom-dialog {
            border: 1px solid var(--border-secondary);
            border-radius: 8px;
            padding: 25px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            box-shadow: 0 5px 20px var(--shadow-secondary);
            min-width: 280px;
            max-width: 500px;
            width: fit-content;
            box-sizing: border-box;
            margin-left: auto;
            margin-right: auto;
            transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            position: relative; /* ダイアログがページコンテンツより上に来るように */
            z-index: 100; /* ダイアログ用の高いz-index */
        }
        .custom-dialog::backdrop {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(3px);
            transition: background-color 0.3s ease;
            z-index: 99; /* バックドロップはダイアログの後ろ */
        }

        body.dark-mode .custom-dialog::backdrop {
            background-color: rgba(30, 30, 30, 0.7);
        }
        .custom-dialog[open] {
            animation: dialog-fade-in 0.3s ease forwards;
        }
        @keyframes dialog-fade-in {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .custom-dialog .dialog-message {
            margin: 0 0 20px 0;
            font-size: 15px;
            line-height: 1.6;
            display: block;
            text-align: left;
        }
        .custom-dialog .dialog-input {
            width: 100%;
            padding: 8px 10px;
            margin-bottom: 20px;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            font-size: 14px;
            background-color: var(--bg-input);
            color: var(--text-primary);
        }
        .custom-dialog .dialog-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 15px;
        }
        .custom-dialog button {
            padding: 8px 18px;
            font-weight: 500;
            min-width: 80px;
        }
        .custom-dialog .dialog-ok-btn {
            background-color: var(--bg-button);
            color: var(--text-light);
        }
        .custom-dialog .dialog-ok-btn:hover:not(:disabled) {
            background-color: var(--bg-button-hover);
        }
         .custom-dialog .dialog-cancel-btn {
            background-color: var(--bg-button-action);
            color: var(--text-light);
        }
        .custom-dialog .dialog-cancel-btn:hover:not(:disabled) {
            background-color: var(--bg-button-action-hover);
        }
    </style>
    <script src="marked.js"></script>
</head>
<body>
    <div class="app-container">

        <!-- チャット画面 -->
        <div id="chat-screen" class="screen active">
            <header class="app-header">
                <button id="goto-history-btn" class="header-button" aria-label="履歴一覧へ">☰</button>
                <h1 id="chat-title">新規チャット</h1>
                <button id="new-chat-btn" class="new-chat-button" title="新規チャットを開始">新規</button>
                <button id="goto-settings-btn" class="header-button" aria-label="設定へ">⚙</button>
            </header>
            <main class="main-content">
                <!-- システムプロンプト表示/編集エリア -->
                <div id="system-prompt-area" class="system-prompt-area">
                    <details id="system-prompt-details">
                        <summary>システムプロンプト</summary>
                        <div class="system-prompt-content">
                            <textarea id="system-prompt-editor" aria-label="システムプロンプト編集"></textarea>
                            <div class="system-prompt-actions">
                                <button id="cancel-system-prompt-btn" class="cancel-system-prompt-btn">キャンセル</button>
                                <button id="save-system-prompt-btn" class="save-system-prompt-btn">保存</button>
                            </div>
                        </div>
                    </details>
                </div>
                <!-- メッセージコンテナ -->
                <div id="message-container" class="message-container">
                    <!-- メッセージはここに読み込まれる -->
                </div>
                <div id="loading-indicator" class="loading-indicator hidden" aria-live="polite">応答中</div>
            </main>
            <footer class="chat-input-area">
                <textarea id="user-input" placeholder="メッセージを入力..." rows="1" aria-label="メッセージ入力"></textarea>
                <button id="send-button" title="送信">送</button>
            </footer>
        </div>

        <!-- 履歴画面 -->
        <div id="history-screen" class="screen">
            <header class="app-header">
                <!-- 要素の順序変更: 戻るボタン -> タイトル -> インポートボタン -->
                <button id="back-to-chat-from-history" class="header-button" aria-label="チャットへ戻る">＞</button>
                <h1 id="history-title">履歴一覧</h1>
                <button id="import-history-btn" class="header-save-button" title="履歴をインポート">インポート</button>
                <input type="file" id="import-history-input" accept=".txt" class="hidden"> <!-- インポート用ファイル入力 -->
            </header>
            <main class="main-content">
                <ul id="history-list" class="history-list">
                    <!-- 履歴アイテムはここに読み込まれる -->
                    <li class="js-history-item-template history-item">
                        <div class="history-item-details">
                            <span class="history-item-title"></span>
                        </div>
                        <div class="history-item-bottom-row">
                            <div class="history-item-dates">
                                <span class="created-date"></span>
                                <span class="updated-date"></span>
                            </div>
                            <div class="history-item-actions">
                                <button class="js-edit-title-btn" title="タイトル編集">✎</button>
                                <button class="js-export-btn" title="出力">出力</button>
                                <button class="js-duplicate-btn" title="複製">複製</button>
                                <button class="js-delete-btn" title="削除">削除</button>
                            </div>
                        </div>
                    </li>
                </ul>
                 <p id="no-history-message" class="hidden" style="text-align: center; color: var(--text-secondary); margin-top: 20px;">チャット履歴はありません。</p>
            </main>
        </div>

        <!-- 設定画面 -->
        <div id="settings-screen" class="screen">
            <header class="app-header">
                 <button id="back-to-chat-from-settings" class="header-button" aria-label="チャットへ戻る">＜</button>
                 <h1>設定</h1>
                 <span id="settings-save-notice" class="header-notice">※反映には保存が必要</span>
                 <button class="js-save-settings-btn header-save-button" title="設定を保存">設定を保存</button>
            </header>
            <main class="main-content">
                <div class="settings-group">
                    <h3>基本設定</h3>
                    <label for="api-key">Gemini APIキー:</label>
                    <input type="password" id="api-key" placeholder="APIキーを入力" aria-label="Gemini APIキー">

                    <label for="model-name">モデル名:</label>
                    <select id="model-name" aria-label="モデル名">
                        <optgroup label="無料">
                            <option value="gemini-2.0-flash">gemini-2.0-flash</option>
                            <option value="gemini-2.5-pro-exp-03-25">gemini-2.5-pro-exp-03-25</option>
                        </optgroup>
                        <optgroup label="有料">
                            <option value="gemini-2.5-pro-preview-03-25">gemini-2.5-pro-preview-03-25</option>
                        </optgroup>
                        <optgroup label="ユーザー指定" id="user-defined-models-group">
                            <!-- 追加モデルはここにJSで挿入される -->
                        </optgroup>
                    </select>

                    <label class="checkbox-label">
                        <input type="checkbox" id="streaming-output">
                        ストリーミング出力を使用する
                    </label>
                    <label for="streaming-speed">文字送り速度 (ミリ秒/文字):</label>
                    <input type="number" id="streaming-speed" min="0" step="1" placeholder="例: 30 (0で無効)" aria-label="文字送り速度">
                </div>

                <div class="settings-group">
                    <h3>パラメータ</h3>
                    <label for="system-prompt-default">システムプロンプト (デフォルト):</label>
                    <textarea id="system-prompt-default" placeholder="例: あなたは親切なアシスタントです。新規チャット作成時に適用されます。" aria-label="システムプロンプト (デフォルト)"></textarea>

                    <div class="param-grid">
                        <div>
                            <label for="max-tokens">Max Tokens:</label>
                            <input type="number" id="max-tokens" step="1" min="1" placeholder="例:1024" aria-label="Max Tokens">
                        </div>
                        <div>
                            <label for="temperature">Temperature:</label>
                            <input type="number" id="temperature" step="0.1" min="0" max="2" placeholder="例:0.9(0.0-2.0)" aria-label="Temperature">
                        </div>
                        <div>
                            <label for="top-k">Top K:</label>
                            <input type="number" id="top-k" step="1" min="1" placeholder="例:40(1-40)" aria-label="Top K">
                        </div>
                        <div>
                            <label for="top-p">Top P:</label>
                            <input type="number" id="top-p" step="0.01" min="0" max="1" placeholder="例:0.95(0.0 - 1.0)" aria-label="Top P">
                        </div>
                    </div>
                </div>

                <div class="settings-group">
                   <h3>アドバンスド</h3>
                   <label for="dummy-user">ダミー User プロンプト (送信時のみ追加):</label>
                   <textarea id="dummy-user" placeholder="API送信直前に user ロールとして履歴末尾に追加されます" aria-label="ダミー User プロンプト"></textarea>

                   <label for="dummy-model">ダミー Model プロンプト (送信時のみ追加):</label>
                   <textarea id="dummy-model" placeholder="API送信直前に model ロールとして履歴最末尾に追加されます" aria-label="ダミー Model プロンプト"></textarea>

                   <label class="checkbox-label">
                       <input type="checkbox" id="concat-dummy-model">
                       ダミーモデルと回答を連結
                   </label>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※チェック時、モデル応答の先頭に上記ダミーModelの内容を付与。
                   </p>

                   <label class="checkbox-label">
                       <input type="checkbox" id="pseudo-streaming">
                       疑似ストリーミングを使用<br> (ストリーミングON時のみ有効)
                   </label>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※実際には一括生成を呼び、応答はストリーミング再生を行う。<br>
                       普通のストリーミングより生成待ち時間は長くなる。
                   </p>
                </div>

                <div class="settings-group">
                    <h3>イメージ画像</h3>
                    <label>チャット画面の背景画像:</label>
                    <div class="image-upload-controls">
                        <!-- 非表示のファイル入力 -->
                        <input type="file" id="background-image-input" accept="image/jpeg, image/png, image/gif, image/webp" class="hidden">
                        <!-- 表示されるアップロードボタン -->
                        <button id="upload-background-btn" class="settings-action-button" type="button">画像を選択...</button>
                        <!-- サムネイルプレビュー -->
                        <img id="background-thumbnail" src="" alt="背景画像プレビュー" class="background-thumbnail hidden">
                        <!-- 削除ボタン (初期非表示) -->
                        <button id="delete-background-btn" class="settings-delete-button hidden" type="button">画像を削除</button>
                    </div>
                     <p style="font-size: 11px; color: var(--text-secondary); margin-top: 8px;">
                       ※ 画像はブラウザ内のデータベースに保存。<br>
                       ※ 可読性のため画像の上に半透明のレイヤーを表示。
                     </p>
                </div>

                <div class="settings-group">
                   <h3>その他設定</h3>
                    <label class="checkbox-label">
                       <input type="checkbox" id="enter-to-send">
                       Enterキーで送信する
                   </label>
                   <!-- ダークモード切り替え -->
                   <label class="checkbox-label">
                       <input type="checkbox" id="dark-mode-toggle">
                       ダークモードを使用する
                   </label>
                   <!-- システムプロンプト非表示設定 -->
                   <label class="checkbox-label">
                       <input type="checkbox" id="hide-system-prompt-toggle">
                       システムプロンプト非表示
                   </label>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※ 没入感を高めたい場合に。非表示でも機能は有効。
                   </p>
                   <label for="history-sort-order">履歴のソート順:</label>
                   <select id="history-sort-order" aria-label="履歴のソート順">
                       <option value="updatedAt">更新日時 (新しい順)</option>
                       <option value="createdAt">作成日時 (新しい順)</option>
                   </select>
                   <!-- フォント指定 -->
                   <label for="font-family-input">アプリのフォント:</label>
                   <input type="text" id="font-family-input" placeholder="例: 'Meiryo', sans-serif" aria-label="アプリ全体のフォント">
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※ 端末またはPCにインストールされているフォント名を指定。
                   </p>
                   <!-- 追加モデル入力欄 -->
                   <label for="additional-models">追加モデル (カンマ区切り):</label>
                   <textarea id="additional-models" placeholder="例: gemini-2.0-pro,gemini-2.0-flash-lite" aria-label="追加モデル"></textarea>
                   <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                       ※ 追加後は設定を保存の上、ページをリロード。
                   </p>
                </div>

                <div class="danger-zone">
                     <!-- バージョン表示 -->
                     <p style="text-align: center; color: var(--text-secondary); font-size: 12px; margin-bottom: 10px;">
                         バージョン: <span id="app-version"></span>
                     </p>
                     <button id="clear-data-btn">全データクリア (履歴と設定)</button>
                     <button id="update-app-btn">アプリを更新 (キャッシュクリア)</button>
                     <p style="font-size: 11px; color: var(--text-secondary); margin-top: -5px; margin-bottom: 10px;">
                         ※ サーバー側のhtmlファイルなどはブラウザにキャッシュされるため、<BR>
                         このボタンで明示的にサーバーがから再取得しない限り更新されない。
                     </p>
                </div>
            </main>
        </div>
    </div>

    <!-- カスタムダイアログテンプレート -->
    <dialog id="alertDialog" class="custom-dialog">
        <p class="dialog-message"></p>
        <div class="dialog-actions">
            <button value="ok" class="dialog-ok-btn">OK</button>
        </div>
    </dialog>

    <dialog id="confirmDialog" class="custom-dialog">
        <p class="dialog-message"></p>
        <div class="dialog-actions">
            <button value="cancel" class="dialog-cancel-btn">キャンセル</button>
            <button value="ok" class="dialog-ok-btn">OK</button>
        </div>
    </dialog>

    <dialog id="promptDialog" class="custom-dialog">
        <label class="dialog-message" for="promptInput"></label>
        <input type="text" id="promptInput" class="dialog-input">
        <div class="dialog-actions">
            <button value="cancel" class="dialog-cancel-btn">キャンセル</button>
            <button value="ok" class="dialog-ok-btn">OK</button>
        </div>
    </dialog>

    <script>
        // --- 定数 ---
        const DB_NAME = 'GeminiPWA_DB';
        const DB_VERSION = 8; // スキーマ変更なしのため据え置き
        const SETTINGS_STORE = 'settings';
        const CHATS_STORE = 'chats';
        const CHAT_UPDATEDAT_INDEX = 'updatedAtIndex';
        const CHAT_CREATEDAT_INDEX = 'createdAtIndex';
        const DEFAULT_MODEL = 'gemini-2.0-flash';
        const DEFAULT_STREAMING_SPEED = 12;
        const DEFAULT_TEMPERATURE = 0.5;
        const DEFAULT_MAX_TOKENS = 4000;
        const DEFAULT_TOP_K = 40;
        const DEFAULT_TOP_P = 0.95;
        const DEFAULT_FONT_FAMILY = '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif'; // デフォルトフォント
        const CHAT_TITLE_LENGTH = 15;
        const TEXTAREA_MAX_HEIGHT = 120;
        const GEMINI_API_BASE_URL = 'https://generativelanguage.googleapis.com/v1beta/models/';
        const DUPLICATE_SUFFIX = ' (コピー)';
        const IMPORT_PREFIX = '(取込) ';
        const LIGHT_THEME_COLOR = '#4a90e2';
        const DARK_THEME_COLOR = '#007aff';
        const APP_VERSION = "0.16"; // 応答候補切り替え機能追加
        const SWIPE_THRESHOLD = 50; // スワイプ判定の閾値 (px)
        const ZOOM_THRESHOLD = 1.01; // ズーム状態と判定するスケールの閾値 (誤差考慮)

        // --- DOM要素 ---
        const elements = {
            appContainer: document.querySelector('.app-container'),
            chatScreen: document.getElementById('chat-screen'),
            historyScreen: document.getElementById('history-screen'),
            settingsScreen: document.getElementById('settings-screen'),
            chatTitle: document.getElementById('chat-title'),
            messageContainer: document.getElementById('message-container'),
            userInput: document.getElementById('user-input'),
            sendButton: document.getElementById('send-button'),
            loadingIndicator: document.getElementById('loading-indicator'),
            historyList: document.getElementById('history-list'),
            historyTitle: document.getElementById('history-title'), // 履歴画面タイトル要素
            noHistoryMessage: document.getElementById('no-history-message'),
            historyItemTemplate: document.querySelector('.js-history-item-template'),
            themeColorMeta: document.getElementById('theme-color-meta'),
            // システムプロンプトUI
            systemPromptArea: document.getElementById('system-prompt-area'),
            systemPromptDetails: document.getElementById('system-prompt-details'),
            systemPromptEditor: document.getElementById('system-prompt-editor'),
            saveSystemPromptBtn: document.getElementById('save-system-prompt-btn'),
            cancelSystemPromptBtn: document.getElementById('cancel-system-prompt-btn'),
            // 設定要素
            apiKeyInput: document.getElementById('api-key'),
            modelNameSelect: document.getElementById('model-name'),
            userDefinedModelsGroup: document.getElementById('user-defined-models-group'), // ユーザー指定モデルのoptgroup
            streamingOutputCheckbox: document.getElementById('streaming-output'),
            streamingSpeedInput: document.getElementById('streaming-speed'),
            systemPromptDefaultTextarea: document.getElementById('system-prompt-default'), // デフォルト用
            temperatureInput: document.getElementById('temperature'),
            maxTokensInput: document.getElementById('max-tokens'),
            topKInput: document.getElementById('top-k'),
            topPInput: document.getElementById('top-p'),
            dummyUserInput: document.getElementById('dummy-user'),
            dummyModelInput: document.getElementById('dummy-model'),
            concatDummyModelCheckbox: document.getElementById('concat-dummy-model'), // ダミーモデル連結チェックボックス
            additionalModelsTextarea: document.getElementById('additional-models'), // 追加モデル入力
            pseudoStreamingCheckbox: document.getElementById('pseudo-streaming'),
            enterToSendCheckbox: document.getElementById('enter-to-send'),
            historySortOrderSelect: document.getElementById('history-sort-order'),
            darkModeToggle: document.getElementById('dark-mode-toggle'),
            fontFamilyInput: document.getElementById('font-family-input'), // フォント指定入力
            hideSystemPromptToggle: document.getElementById('hide-system-prompt-toggle'), // SP非表示トグル
            appVersionSpan: document.getElementById('app-version'),
            // 背景画像設定要素
            backgroundImageInput: document.getElementById('background-image-input'),
            uploadBackgroundBtn: document.getElementById('upload-background-btn'),
            backgroundThumbnail: document.getElementById('background-thumbnail'),
            deleteBackgroundBtn: document.getElementById('delete-background-btn'),
            // ボタン
            gotoHistoryBtn: document.getElementById('goto-history-btn'),
            gotoSettingsBtn: document.getElementById('goto-settings-btn'),
            backToChatFromHistoryBtn: document.getElementById('back-to-chat-from-history'),
            backToChatFromSettingsBtn: document.getElementById('back-to-chat-from-settings'),
            newChatBtn: document.getElementById('new-chat-btn'),
            saveSettingsBtns: document.querySelectorAll('.js-save-settings-btn'),
            updateAppBtn: document.getElementById('update-app-btn'),
            clearDataBtn: document.getElementById('clear-data-btn'),
            importHistoryBtn: document.getElementById('import-history-btn'), // 履歴インポートボタン
            importHistoryInput: document.getElementById('import-history-input'), // 履歴インポートファイル入力
            // カスタムダイアログ
            alertDialog: document.getElementById('alertDialog'),
            alertMessage: document.getElementById('alertDialog').querySelector('.dialog-message'),
            alertOkBtn: document.getElementById('alertDialog').querySelector('.dialog-ok-btn'),
            confirmDialog: document.getElementById('confirmDialog'),
            confirmMessage: document.getElementById('confirmDialog').querySelector('.dialog-message'),
            confirmOkBtn: document.getElementById('confirmDialog').querySelector('.dialog-ok-btn'),
            confirmCancelBtn: document.getElementById('confirmDialog').querySelector('.dialog-cancel-btn'),
            promptDialog: document.getElementById('promptDialog'),
            promptMessage: document.getElementById('promptDialog').querySelector('.dialog-message'),
            promptInput: document.getElementById('promptDialog').querySelector('.dialog-input'),
            promptOkBtn: document.getElementById('promptDialog').querySelector('.dialog-ok-btn'),
            promptCancelBtn: document.getElementById('promptDialog').querySelector('.dialog-cancel-btn'),
        };

        // --- アプリ状態 ---
        const state = {
            db: null,
            currentChatId: null,
            currentMessages: [], // メッセージオブジェクトには isCascaded, isSelected, siblingGroupId が含まれる可能性がある
            currentSystemPrompt: '', // 現在のチャットのシステムプロンプト
            settings: { // デフォルト値
                apiKey: '',
                modelName: DEFAULT_MODEL,
                streamingOutput: true,
                streamingSpeed: DEFAULT_STREAMING_SPEED,
                systemPrompt: '', // デフォルトのシステムプロンプト
                temperature: null,
                maxTokens: null,
                topK: null,
                topP: null,
                dummyUser: '',
                dummyModel: '',
                concatDummyModel: false, // ダミーモデル連結設定
                additionalModels: '', // 追加モデル用設定
                pseudoStreaming: false,
                enterToSend: true,
                historySortOrder: 'updatedAt',
                darkMode: false, // デフォルトはダークモードOFF
                backgroundImageBlob: null, // デフォルト背景はnull
                fontFamily: '', // デフォルトフォントは空 (CSS変数で定義)
                hideSystemPromptInChat: false, // SP非表示設定 (デフォルトfalse)
            },
            backgroundImageUrl: null, // 生成されたオブジェクトURL (DBには保存しない)
            isSending: false,
            abortController: null,
            partialStreamContent: '',
            editingMessageIndex: null,
            isEditingSystemPrompt: false, // システムプロンプト編集中フラグ
            touchStartX: 0, // スワイプ開始X座標
            touchStartY: 0, // スワイプ開始Y座標
            touchEndX: 0,   // スワイプ終了X座標
            touchEndY: 0,   // スワイプ終了Y座標
            isSwiping: false, // スワイプ中フラグ
            isZoomed: false, // ズーム状態フラグ
            currentScreen: 'chat', // 現在表示中の画面名 (戻るボタン制御用)
        };

        function updateMessageMaxWidthVar() {
            const container = elements.messageContainer; // messageContainer要素を取得
            if (!container) return;

            // コンテナ幅に基づいて最大幅を計算
            let maxWidthPx = container.clientWidth * 0.8;

            // 計算したピクセル値をCSS変数に設定
            document.documentElement.style.setProperty('--message-max-width', `${maxWidthPx}px`);
            // console.log(`CSS Variable --message-max-width updated to: ${maxWidthPx}px`); // ログ削減
        }

        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            // Debounce処理: リサイズ完了後に一度だけ実行
            resizeTimer = setTimeout(updateMessageMaxWidthVar, 150);
        });

        // --- ユーティリティ関数 ---
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // --- Service Worker関連 ---
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js')
                        .then(registration => {
                            console.log('ServiceWorker登録成功 スコープ: ', registration.scope);
                            // Service Workerからのメッセージ受信
                            navigator.serviceWorker.addEventListener('message', event => {
                                if (event.data && event.data.action === 'reloadPage') {
                                    alert('アプリが更新されました。ページをリロードします。');
                                    window.location.reload();
                                }
                            });
                        })
                        .catch(err => {
                            console.error('ServiceWorker登録失敗: ', err);
                        });
                });
            } else {
                console.warn('このブラウザはService Workerをサポートしていません。');
            }
        }

        // --- IndexedDBユーティリティ (dbUtils) ---
        const dbUtils = {
            openDB() {
                return new Promise((resolve, reject) => {
                    if (state.db) {
                        resolve(state.db);
                        return;
                    }
                    const request = indexedDB.open(DB_NAME, DB_VERSION);

                    request.onerror = (event) => {
                        console.error("IndexedDBエラー:", event.target.error);
                        reject(`IndexedDBエラー: ${event.target.error}`);
                    };

                    request.onsuccess = (event) => {
                        state.db = event.target.result;
                        console.log("IndexedDBオープン成功");
                        // DB全体のエラーハンドリング
                        state.db.onerror = (event) => {
                            console.error(`データベースエラー: ${event.target.error}`);
                        };
                        resolve(state.db);
                    };

                    // DBバージョン更新時 (スキーマ変更)
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        const transaction = event.target.transaction;
                        console.log(`IndexedDBをバージョン ${event.oldVersion} から ${event.newVersion} へアップグレード中...`);

                        // 設定ストア (変更なし)
                        if (!db.objectStoreNames.contains(SETTINGS_STORE)) {
                            db.createObjectStore(SETTINGS_STORE, { keyPath: 'key' });
                            console.log(`オブジェクトストア ${SETTINGS_STORE} 作成`);
                        }

                        // チャットストア & インデックス (変更なし、新しいフラグは動的に追加される)
                        let chatStore;
                        if (!db.objectStoreNames.contains(CHATS_STORE)) {
                            chatStore = db.createObjectStore(CHATS_STORE, { keyPath: 'id', autoIncrement: true });
                            console.log(`オブジェクトストア ${CHATS_STORE} 作成`);
                        } else {
                             if (transaction) {
                                try { chatStore = transaction.objectStore(CHATS_STORE); } catch (e) { console.error("チャットストアの取得中にエラー(アップグレード):", e); return; }
                            } else { console.warn("チャットストアのアップグレード用トランザクション取得失敗"); }
                        }

                        // インデックスが存在することを確認
                        if (chatStore && !chatStore.indexNames.contains(CHAT_UPDATEDAT_INDEX)) {
                            chatStore.createIndex(CHAT_UPDATEDAT_INDEX, 'updatedAt', { unique: false });
                            console.log(`インデックス ${CHAT_UPDATEDAT_INDEX} を ${CHATS_STORE} に作成`);
                        }
                        if (chatStore && !chatStore.indexNames.contains(CHAT_CREATEDAT_INDEX)) {
                            chatStore.createIndex(CHAT_CREATEDAT_INDEX, 'createdAt', { unique: false });
                            console.log(`インデックス ${CHAT_CREATEDAT_INDEX} を ${CHATS_STORE} に作成`);
                        }

                        // V8以降: 新しいフラグ (isCascaded, isSelected, siblingGroupId) は
                        // スキーマレスなIndexedDBの特性により、保存時に自動的に追加される。
                        // 読み込み時に存在しない場合はデフォルト値として扱う。
                        if (event.oldVersion < 8) { // 以前のバージョンからのアップグレードの場合
                            console.log("DBアップグレード: 新しいメッセージフラグは動的に処理されます。");
                        }
                    };
                });
            },

            // 指定されたストアを取得する内部関数
            _getStore(storeName, mode = 'readonly') {
                if (!state.db) throw new Error("データベースが開かれていません");
                const transaction = state.db.transaction([storeName], mode);
                return transaction.objectStore(storeName);
            },

            // 設定を保存
            async saveSetting(key, value) {
                await this.openDB();
                return new Promise((resolve, reject) => {
                     try {
                        const store = this._getStore(SETTINGS_STORE, 'readwrite');
                        // IndexedDBはBlobを直接扱える
                        const request = store.put({ key, value });
                        request.onsuccess = () => {
                             // console.log(`設定 '${key}' 保存成功`); // ログは必要に応じて
                             resolve();
                        };
                        request.onerror = (event) => {
                             console.error(`設定 ${key} の保存エラー:`, event.target.error);
                             reject(`設定 ${key} の保存エラー: ${event.target.error}`);
                        };
                    } catch (error) {
                        console.error(`設定 ${key} 保存のためのストアアクセスエラー:`, error);
                        reject(`設定 ${key} 保存のためのストアアクセスエラー: ${error}`);
                    }
                });
            },

            // 全設定を読み込み
            async loadSettings() {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(SETTINGS_STORE);
                    const request = store.getAll();

                    request.onsuccess = (event) => {
                        const settingsArray = event.target.result;
                        const loadedSettings = {};
                        settingsArray.forEach(item => {
                            loadedSettings[item.key] = item.value;
                        });

                        // stateから初期のデフォルト設定を取得
                        const defaultSettings = { ...state.settings };

                        // state.settingsをデフォルトにリセットしてから読み込んだ値を適用
                        state.settings = { ...defaultSettings };

                        // デフォルト値の上に読み込んだ値を適用し、型安全性を確保
                        for (const key in loadedSettings) {
                             if (key in defaultSettings) { // デフォルト状態に存在するキーのみ処理
                                const loadedValue = loadedSettings[key];
                                const defaultValue = defaultSettings[key];

                                if (key === 'backgroundImageBlob') {
                                    // 背景画像はBlobまたはnullのみ受け入れる
                                    if (loadedValue instanceof Blob) {
                                         state.settings[key] = loadedValue;
                                    } else {
                                         if (loadedValue !== null) console.warn(`読み込んだ 'backgroundImageBlob' がBlobではありません。nullに設定します。型: ${typeof loadedValue}`);
                                         state.settings[key] = null; // Blobでないか明示的にnullならnullを使用
                                    }
                                } else if (key === 'hideSystemPromptInChat') { // SP非表示設定
                                    state.settings[key] = loadedValue === true;
                                } else if (key === 'darkMode' || key === 'streamingOutput' || key === 'pseudoStreaming' || key === 'enterToSend' || key === 'concatDummyModel') {
                                     // その他の真偽値: 厳密にtrueかチェック
                                     state.settings[key] = loadedValue === true;
                                } else if (typeof defaultValue === 'number' || defaultValue === null) {
                                     // 数値 (オプションのものはnullを扱う)
                                     let num;
                                     if (key === 'temperature' || key === 'topP') {
                                         num = parseFloat(loadedValue);
                                     } else { // streamingSpeed, maxTokens, topK
                                         num = parseInt(loadedValue, 10);
                                     }

                                     // パース失敗、またはオプションパラメータがnull/空で読み込まれたかチェック
                                     if (isNaN(num)) {
                                         // パース失敗した場合、オプションパラメータで元々null/空が意図されていたかチェック
                                         if ((key === 'temperature' || key === 'maxTokens' || key === 'topK' || key === 'topP') && (loadedValue === null || loadedValue === '')) {
                                              state.settings[key] = null; // nullのままにする
                                         } else {
                                              state.settings[key] = defaultValue; // 不正な必須数値ならデフォルトにリセット
                                         }
                                     } else {
                                          // 範囲を持つ数値のバリデーション (オプション)
                                          if (key === 'temperature' && (num < 0 || num > 2)) num = defaultValue;
                                          if (key === 'maxTokens' && num < 1) num = defaultValue;
                                          if (key === 'topK' && num < 1) num = defaultValue;
                                          if (key === 'topP' && (num < 0 || num > 1)) num = defaultValue;
                                          if (key === 'streamingSpeed' && num < 0) num = defaultValue;
                                          state.settings[key] = num;
                                     }
                                } else if (typeof defaultValue === 'string') {
                                     // 文字列: 読み込んだ値が文字列なら使用、そうでなければデフォルト
                                     state.settings[key] = typeof loadedValue === 'string' ? loadedValue : defaultValue;
                                } else {
                                    // defaultSettingsが適切に定義されていればここには来ないはず
                                    console.warn(`予期しない設定タイプ キー: ${key}`);
                                    state.settings[key] = loadedValue;
                                }
                            } else {
                                console.warn(`DBから読み込んだ未知の設定を無視: ${key}`);
                            }
                        }

                        // 設定が明示的にtrueとして保存されていない場合、OSのダークモード設定を初期適用
                        if (state.settings.darkMode !== true && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                             console.log("OSのダークモード設定を初期適用");
                             state.settings.darkMode = true;
                             // 注意: これはDBにはすぐ保存しない。ユーザーが切り替えて保存する必要がある
                        }


                        console.log("設定読み込み完了:", { ...state.settings, backgroundImageBlob: state.settings.backgroundImageBlob ? '[Blob]' : null });
                        resolve(state.settings);
                    };
                    request.onerror = (event) => reject(`設定読み込みエラー: ${event.target.error}`);
                });
            },

            // チャットを保存 (タイトル指定可)
            async saveChat(optionalTitle = null) {
                await this.openDB();
                // メッセージもシステムプロンプトもない場合は保存しない
                if ((!state.currentMessages || state.currentMessages.length === 0) && !state.currentSystemPrompt) {
                    if(state.currentChatId) console.log(`saveChat: 既存チャット ${state.currentChatId} にメッセージもシステムプロンプトもないため保存せず`);
                    else console.log("saveChat: 新規チャットに保存するメッセージもシステムプロンプトもなし");
                    return Promise.resolve(state.currentChatId); // 現在のIDを返す
                }

                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE, 'readwrite');
                    const now = Date.now();
                    // 保存するメッセージデータを作成 (必要なプロパティのみ + 新しいフラグ)
                    const messagesToSave = state.currentMessages.map(msg => ({
                        role: msg.role,
                        content: msg.content,
                        timestamp: msg.timestamp,
                        ...(msg.finishReason && { finishReason: msg.finishReason }),
                        ...(msg.safetyRatings && { safetyRatings: msg.safetyRatings }),
                        ...(msg.error && { error: msg.error }),
                        // 新しいフラグを追加 (存在すれば)
                        ...(msg.isCascaded !== undefined && { isCascaded: msg.isCascaded }),
                        ...(msg.isSelected !== undefined && { isSelected: msg.isSelected }),
                        ...(msg.siblingGroupId !== undefined && { siblingGroupId: msg.siblingGroupId }),
                    }));

                    // タイトルを決定して保存を実行する内部関数
                    const determineTitleAndSave = (existingChatData = null) => {
                        let title;
                        if (optionalTitle !== null) { // 引数でタイトルが指定されていればそれを使う
                            title = optionalTitle;
                        } else if (existingChatData && existingChatData.title) { // 既存データにタイトルがあればそれを使う
                            title = existingChatData.title;
                        } else { // それ以外は最初のユーザーメッセージから生成
                            const firstUserMessage = state.currentMessages.find(m => m.role === 'user');
                            title = firstUserMessage ? firstUserMessage.content.substring(0, 50) : "無題のチャット";
                        }

                        const chatIdForOperation = existingChatData ? existingChatData.id : state.currentChatId;
                        const chatData = {
                            messages: messagesToSave,
                            systemPrompt: state.currentSystemPrompt, // システムプロンプトを保存
                            updatedAt: now,
                            createdAt: existingChatData ? existingChatData.createdAt : now, // 新規なら現在時刻
                            title: title,
                        };
                        if (chatIdForOperation) { // IDがあれば更新なのでIDを付与
                            chatData.id = chatIdForOperation;
                        }

                        const request = store.put(chatData); // putは新規・更新両対応
                        request.onsuccess = (event) => {
                            const savedId = event.target.result;
                            if (!state.currentChatId && savedId) { // 新規保存でIDが確定したらstateに反映
                                state.currentChatId = savedId;
                            }
                            console.log(`チャット ${state.currentChatId ? '更新' : '保存'} 完了 ID:`, state.currentChatId || savedId);
                            // 保存したチャットが現在表示中のものなら、タイトルをUIに反映
                            if ((state.currentChatId || savedId) === (chatIdForOperation || savedId)) {
                                uiUtils.updateChatTitle(chatData.title);
                            }
                            resolve(state.currentChatId || savedId); // 保存/更新後のIDを返す
                        };
                        request.onerror = (event) => reject(`チャット保存エラー: ${event.target.error}`);
                    };

                    // 現在のチャットIDがあるか (更新か新規か)
                    if (state.currentChatId) {
                        // 更新の場合、既存のデータを取得してcreatedAtを引き継ぐ
                        const getRequest = store.get(state.currentChatId);
                        getRequest.onsuccess = (event) => {
                            const existingChat = event.target.result;
                             if (!existingChat) { // IDはあるがデータがない場合 (削除されたなど) は新規として保存
                                 console.warn(`ID ${state.currentChatId} のチャットが見つかりません(保存時)。新規として保存します。`);
                                 state.currentChatId = null; // IDをリセット
                                 determineTitleAndSave(null);
                            } else {
                                determineTitleAndSave(existingChat); // 既存データを使って保存
                            }
                        };
                        getRequest.onerror = (event) => {
                            // 既存データの取得に失敗した場合も、とりあえず新規として保存を試みる
                            console.error("既存チャットの取得エラー(更新用):", event.target.error);
                            console.warn("既存チャット取得エラーのため、新規として保存を試みます。");
                            state.currentChatId = null; // IDをリセット
                            determineTitleAndSave(null);
                        };
                    } else {
                        // 新規保存の場合
                        determineTitleAndSave(null);
                    }

                    // トランザクション全体のエラーハンドリング
                    store.transaction.onerror = (event) => {
                        console.error("チャット保存トランザクション失敗:", event.target.error);
                        reject(`チャット保存トランザクション失敗: ${event.target.error}`);
                    };
                    // store.transaction.oncomplete = () => { console.log("チャット保存トランザクション完了"); };
                });
            },

            // チャットタイトルをDBで更新
            async updateChatTitleDb(id, newTitle) {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE, 'readwrite');
                    const getRequest = store.get(id);
                    getRequest.onsuccess = (event) => {
                        const chatData = event.target.result;
                        if (chatData) {
                            chatData.title = newTitle;
                            chatData.updatedAt = Date.now(); // 更新日時も更新
                            const putRequest = store.put(chatData);
                            putRequest.onsuccess = () => resolve();
                            putRequest.onerror = (event) => reject(`タイトル更新エラー: ${event.target.error}`);
                        } else {
                            reject(`チャットが見つかりません: ${id}`);
                        }
                    };
                    getRequest.onerror = (event) => reject(`タイトル更新用チャット取得エラー: ${event.target.error}`);
                    store.transaction.onerror = (event) => reject(`タイトル更新トランザクション失敗: ${event.target.error}`);
                });
            },

            // 指定IDのチャットを取得
            async getChat(id) {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE);
                    const request = store.get(id);
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(`チャット ${id} 取得エラー: ${event.target.error}`);
                });
            },

            // 全チャットを取得 (ソート順指定可)
            async getAllChats(sortBy = 'updatedAt') {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE);
                    const indexName = sortBy === 'createdAt' ? CHAT_CREATEDAT_INDEX : CHAT_UPDATEDAT_INDEX;
                    // インデックスが存在するか確認
                    if (!store.indexNames.contains(indexName)) {
                         console.error(`インデックス "${indexName}" が見つかりません。主キー順でフォールバックします。`);
                         // フォールバック: 主キー順で取得して逆順にする
                         const getAllRequest = store.getAll();
                         getAllRequest.onsuccess = (event) => resolve(event.target.result.reverse()); // 新しいものが上に来るように
                         getAllRequest.onerror = (event) => reject(`全チャット取得エラー(フォールバック): ${event.target.error}`);
                         return;
                    }
                    // インデックスを使ってカーソルを開く (降順)
                    const index = store.index(indexName);
                    const request = index.openCursor(null, 'prev'); // 'prev'で降順
                    const chats = [];
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            chats.push(cursor.value);
                            cursor.continue();
                        } else {
                            // カーソル終了
                            resolve(chats);
                        }
                    };
                    request.onerror = (event) => reject(`全チャット取得エラー (${sortBy}順): ${event.target.error}`);
                });
            },

            // 指定IDのチャットを削除
            async deleteChat(id) {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const store = this._getStore(CHATS_STORE, 'readwrite');
                    const request = store.delete(id);
                    request.onsuccess = () => { console.log("チャット削除:", id); resolve(); };
                    request.onerror = (event) => reject(`チャット ${id} 削除エラー: ${event.target.error}`);
                });
            },

            // 全データ (設定とチャット) をクリア
            async clearAllData() {
                await this.openDB();
                return new Promise((resolve, reject) => {
                    const transaction = state.db.transaction([SETTINGS_STORE, CHATS_STORE], 'readwrite');
                    let storesCleared = 0;
                    const totalStores = 2;

                    const onComplete = () => {
                        if (++storesCleared === totalStores) {
                            console.log("IndexedDBの全データ削除完了");
                            resolve();
                        }
                    };
                    const onError = (storeName, event) => reject(`${storeName} クリアエラー: ${event.target.error}`);

                    const settingsStore = transaction.objectStore(SETTINGS_STORE);
                    const chatsStore = transaction.objectStore(CHATS_STORE);

                    const clearSettingsReq = settingsStore.clear();
                    const clearChatsReq = chatsStore.clear();

                    clearSettingsReq.onsuccess = onComplete;
                    clearSettingsReq.onerror = (e) => onError(SETTINGS_STORE, e);
                    clearChatsReq.onsuccess = onComplete;
                    clearChatsReq.onerror = (e) => onError(CHATS_STORE, e);

                    transaction.onerror = (event) => reject(`データクリアトランザクション失敗: ${event.target.error}`);
                });
            }
        };

        // --- UIユーティリティ (uiUtils) ---
        const uiUtils = {
            // チャットメッセージをレンダリング
            renderChatMessages() {
                // 編集中ならキャンセル
                if (state.editingMessageIndex !== null) {
                    const messageElement = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                    if(messageElement) appLogic.cancelEditMessage(state.editingMessageIndex, messageElement);
                    else state.editingMessageIndex = null; // 要素が見つからない場合もインデックスをリセット
                }
                elements.messageContainer.innerHTML = ''; // コンテナをクリア

                // メッセージをループして表示
                let currentSiblingGroupId = null;
                let siblingsInGroup = [];
                let siblingIndex = 0;

                for (let i = 0; i < state.currentMessages.length; i++) {
                    const msg = state.currentMessages[i];

                    if (msg.role === 'model' && msg.isCascaded && msg.siblingGroupId) {
                        // カスケード応答グループの開始または継続
                        if (msg.siblingGroupId !== currentSiblingGroupId) {
                            // 新しいグループの開始
                            currentSiblingGroupId = msg.siblingGroupId;
                            // このグループに属するすべてのメッセージを取得
                            siblingsInGroup = state.currentMessages.filter(m => m.role === 'model' && m.isCascaded && m.siblingGroupId === currentSiblingGroupId);
                            siblingIndex = 0; // グループ内のインデックスをリセット
                        }

                        // グループ内の現在のメッセージのインデックスを見つける
                        const currentIndexInGroup = siblingsInGroup.findIndex(m => m === msg);
                        if (currentIndexInGroup !== -1) {
                            siblingIndex = currentIndexInGroup + 1; // 1ベースのインデックス
                        }

                        // isSelected が true のメッセージのみ表示
                        if (msg.isSelected) {
                            this.appendMessage(msg.role, msg.content, i, false, {
                                currentIndex: siblingIndex,
                                total: siblingsInGroup.length,
                                siblingGroupId: currentSiblingGroupId
                            });
                        } else {
                            // isSelected でないカスケードメッセージはDOMに追加しないか、hiddenクラスを付与
                            // ここではDOMに追加しない方針とする
                            console.log(`Skipping render for non-selected cascaded message index ${i}`);
                        }
                    } else {
                        // 通常のメッセージ (user, error, または非カスケード model)
                        currentSiblingGroupId = null; // グループをリセット
                        siblingsInGroup = [];
                        this.appendMessage(msg.role, msg.content, i);
                    }
                }
                //this.scrollToBottom(); // 最下部へスクロールは削除、呼び出し元の責任で行う
            },

            // メッセージをコンテナに追加
            appendMessage(role, content, index, isStreamingPlaceholder = false, cascadeInfo = null) {
                const messageDiv = document.createElement('div');
                messageDiv.classList.add('message', role);
                messageDiv.dataset.index = index; // state.currentMessages 内のインデックス

                // isSelected: false のカスケードメッセージは非表示 (renderChatMessagesでDOMに追加しない方針にしたため、このチェックは不要かも)
                // if (role === 'model' && state.currentMessages[index]?.isCascaded && !state.currentMessages[index]?.isSelected) {
                //     messageDiv.classList.add('hidden');
                // }

                const contentDiv = document.createElement('div');
                contentDiv.classList.add('message-content');

                try {
                    // モデルのメッセージで、ストリーミングプレースホルダーでなければMarkdownをパース
                    if (role === 'model' && !isStreamingPlaceholder && typeof marked !== 'undefined') {
                        contentDiv.innerHTML = marked.parse(content || ''); // marked.jsでパース
                    } else if (role === 'user') { // ユーザーメッセージはpreタグでそのまま表示
                        const pre = document.createElement('pre'); pre.textContent = content; contentDiv.appendChild(pre);
                    } else if (role === 'error') { // エラーメッセージ
                         const p = document.createElement('p'); p.textContent = content; contentDiv.appendChild(p);
                    } else if (isStreamingPlaceholder) { // ストリーミング中のプレースホルダー
                        contentDiv.innerHTML = ''; // 最初は空
                    } else { // その他の場合 (予期しないロールなど) はpreタグで表示
                        const pre = document.createElement('pre'); pre.textContent = content; contentDiv.appendChild(pre);
                    }
                } catch (e) {
                     // Markdownパースエラー時
                     console.error("Markdownパースエラー:", e);
                     const pre = document.createElement('pre'); pre.textContent = content; contentDiv.innerHTML = ''; contentDiv.appendChild(pre);
                }
                messageDiv.appendChild(contentDiv);

                // 編集用エリア (初期非表示)
                const editArea = document.createElement('div');
                editArea.classList.add('message-edit-area', 'hidden');
                messageDiv.appendChild(editArea);

                // --- カスケードコントロール (上部) ---
                if (role === 'model' && cascadeInfo && cascadeInfo.total > 1) {
                    const cascadeControlsDiv = document.createElement('div');
                    cascadeControlsDiv.classList.add('message-cascade-controls');

                    // 前へボタン
                    const prevButton = document.createElement('button');
                    prevButton.textContent = '＜';
                    prevButton.title = '前の応答';
                    prevButton.classList.add('cascade-prev-btn');
                    prevButton.disabled = cascadeInfo.currentIndex <= 1;
                    prevButton.onclick = () => appLogic.navigateCascade(index, 'prev');
                    cascadeControlsDiv.appendChild(prevButton);

                    // インジケーター (例: 1/3)
                    const indicatorSpan = document.createElement('span');
                    indicatorSpan.classList.add('cascade-indicator');
                    indicatorSpan.textContent = `${cascadeInfo.currentIndex}/${cascadeInfo.total}`;
                    cascadeControlsDiv.appendChild(indicatorSpan);

                    // 次へボタン
                    const nextButton = document.createElement('button');
                    nextButton.textContent = '＞';
                    nextButton.title = '次の応答';
                    nextButton.classList.add('cascade-next-btn');
                    nextButton.disabled = cascadeInfo.currentIndex >= cascadeInfo.total;
                    nextButton.onclick = () => appLogic.navigateCascade(index, 'next');
                    cascadeControlsDiv.appendChild(nextButton);

                    // この応答を削除ボタン
                    const deleteCascadeButton = document.createElement('button');
                    deleteCascadeButton.textContent = '✕'; // または '削除'
                    deleteCascadeButton.title = 'この応答を削除';
                    deleteCascadeButton.classList.add('cascade-delete-btn');
                    deleteCascadeButton.onclick = () => appLogic.confirmDeleteCascadeResponse(index);
                    cascadeControlsDiv.appendChild(deleteCascadeButton);

                    messageDiv.appendChild(cascadeControlsDiv); // メッセージ要素に追加
                }
                // --- カスケードコントロールここまで ---

                // エラーメッセージ以外にはアクションボタンを追加 (下部)
                if (role !== 'error') {
                    const actionsDiv = document.createElement('div');
                    actionsDiv.classList.add('message-actions');

                    // 編集ボタン
                    const editButton = document.createElement('button');
                    editButton.textContent = '編集'; editButton.title = 'メッセージを編集'; editButton.classList.add('js-edit-btn');
                    editButton.onclick = () => appLogic.startEditMessage(index, messageDiv);
                    actionsDiv.appendChild(editButton);

                    // 削除ボタン (メッセージペア全体削除)
                    const deleteButton = document.createElement('button');
                    deleteButton.textContent = '削除'; deleteButton.title = 'この会話ターンを削除'; deleteButton.classList.add('js-delete-btn');
                    deleteButton.onclick = () => appLogic.deleteMessage(index); // 既存の全体削除関数
                    actionsDiv.appendChild(deleteButton);

                    // ユーザーメッセージにはリトライボタンも追加
                    if (role === 'user') {
                        const retryButton = document.createElement('button');
                        retryButton.textContent = 'リトライ'; retryButton.title = 'このメッセージから再生成'; retryButton.classList.add('js-retry-btn');
                        retryButton.onclick = () => appLogic.retryFromMessage(index);
                        actionsDiv.appendChild(retryButton);
                    }
                    messageDiv.appendChild(actionsDiv);
                }

                // ストリーミングプレースホルダーの場合、IDを付与して後で更新できるようにする
                if (isStreamingPlaceholder) {
                    messageDiv.id = `streaming-message-${index}`;
                }
                elements.messageContainer.appendChild(messageDiv);
            },

            // ストリーミング中のメッセージを更新
            updateStreamingMessage(index, newChar) {
                const messageDiv = document.getElementById(`streaming-message-${index}`);
                if (messageDiv && typeof marked !== 'undefined') {
                    const contentDiv = messageDiv.querySelector('.message-content');
                    if (contentDiv) {
                        try {
                            // 部分的なコンテンツをMarkdownとしてパースして表示
                            contentDiv.innerHTML = marked.parse(state.partialStreamContent || '');
                        } catch (e) {
                            console.error("ストリーミング更新中のMarkdownパースエラー:", e);
                            contentDiv.textContent = state.partialStreamContent; // エラー時はテキストとして表示
                        }
                    }
                    this.scrollToBottom(); // 更新のたびにスクロール
                }
            },

            // ストリーミングメッセージの完了処理
            finalizeStreamingMessage(index) {
                const messageDiv = document.getElementById(`streaming-message-${index}`);
                if (messageDiv) {
                    const contentDiv = messageDiv.querySelector('.message-content');
                    // stateから最終的なコンテンツを取得
                    const finalRawContent = state.currentMessages[index]?.content || '';
                    if (contentDiv && typeof marked !== 'undefined') {
                         try {
                             // 最終コンテンツをMarkdownとしてパース
                             contentDiv.innerHTML = marked.parse(finalRawContent);
                         } catch (e) {
                             console.error("ストリーミング完了時のMarkdownパースエラー:", e);
                             contentDiv.textContent = finalRawContent; // エラー時はテキスト表示
                         }
                    } else if (contentDiv) {
                        contentDiv.textContent = finalRawContent; // markedがない場合のフォールバック
                    }
                    messageDiv.removeAttribute('id'); // IDを削除

                    // ストリーミング完了後、カスケードコントロールが必要かチェックして再描画
                    // (リトライ直後など、応答候補が増えた場合に必要)
                    const msgData = state.currentMessages[index];
                    if (msgData && msgData.role === 'model' && msgData.isCascaded) {
                        const siblings = appLogic.getCascadedSiblings(index);
                        if (siblings.length > 1) {
                            // コントロールを再生成または更新
                            // 一旦、renderChatMessagesを呼び出すのが簡単かもしれない
                            this.renderChatMessages(); // UI全体を再描画
                        }
                    }
                }
                this.scrollToBottom(); // 最後にスクロール
            },

            // エラーメッセージを表示
            displayError(message, isApiError = false) {
                console.error("エラー表示:", message);
                const errorIndex = state.currentMessages.length; // 現在のメッセージリストの末尾に追加
                this.appendMessage('error', `エラー: ${message}`, errorIndex);
                elements.loadingIndicator.classList.add('hidden'); // ローディング非表示
                this.setSendingState(false); // 送信状態解除
            },

            // チャットコンテナの最下部へスクロール
            scrollToBottom() {
                requestAnimationFrame(() => { // 次の描画タイミングで実行
                    const mainContent = elements.chatScreen.querySelector('.main-content');
                    if (mainContent) {
                        mainContent.scrollTop = mainContent.scrollHeight;
                    }
                });
            },

            // チャットタイトルを更新
            updateChatTitle(definitiveTitle = null) {
                let titleText = '新規チャット';
                let baseTitle = '';
                let isNewChat = !state.currentChatId;

                if (state.currentChatId) { // 既存チャットの場合
                    isNewChat = false;
                    if (definitiveTitle !== null) { // 引数でタイトルが指定されていればそれを使う
                        baseTitle = definitiveTitle;
                    } else { // 指定がなければメッセージから推測 (ユーザーメッセージ優先)
                        const firstUserMessage = state.currentMessages.find(m => m.role === 'user');
                        if (firstUserMessage) {
                            baseTitle = firstUserMessage.content;
                        } else if (state.currentMessages.length > 0) { // ユーザーメッセージ以外でもメッセージがあれば
                            baseTitle = "チャット履歴";
                        }
                    }
                    // タイトルを切り詰める
                    if(baseTitle) {
                        // インポート接頭辞を除いて切り詰める
                        const displayBase = baseTitle.startsWith(IMPORT_PREFIX) ? baseTitle.substring(IMPORT_PREFIX.length) : baseTitle;
                        const truncated = displayBase.substring(0, CHAT_TITLE_LENGTH);
                        titleText = truncated + (displayBase.length > CHAT_TITLE_LENGTH ? '...' : '');
                        // インポート接頭辞を再度付与
                        if (baseTitle.startsWith(IMPORT_PREFIX)) {
                            titleText = IMPORT_PREFIX + titleText;
                        }
                    } else if(state.currentMessages.length > 0) { // メッセージがあれば (SPは考慮しない)
                        titleText = 'チャット履歴';
                    }
                    // メッセージがあるのにタイトルが「新規チャット」のままなら変更
                    if (titleText === '新規チャット' && state.currentMessages.length > 0) { // メッセージがあれば (SPは考慮しない)
                        titleText = 'チャット履歴';
                    }
                }
                // 表示用タイトル (既存チャットならプレフィックス追加)
                const displayTitle = isNewChat ? titleText : `: ${titleText}`;
                elements.chatTitle.textContent = displayTitle;
                document.title = `GeminiPWA - ${titleText}`; // ブラウザタブのタイトルも更新
            },

            // タイムスタンプをフォーマット
            formatDate(timestamp) {
                if (!timestamp) return '';
                try {
                    // 日本語形式でフォーマット
                    return new Intl.DateTimeFormat('ja-JP', { year: '2-digit', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', hour12: false }).format(new Date(timestamp));
                } catch (e) {
                    // Intlが使えない場合のフォールバック
                    console.warn("Intl.DateTimeFormatエラー:", e);
                    const d = new Date(timestamp);
                    return `${String(d.getFullYear()).slice(-2)}/${String(d.getMonth() + 1).padStart(2, '0')}/${String(d.getDate()).padStart(2, '0')} ${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}`;
                }
            },

            // 履歴リストをレンダリング
            async renderHistoryList() {
                try {
                    const chats = await dbUtils.getAllChats(state.settings.historySortOrder);
                    // 既存のアイテムを削除 (テンプレートを除く)
                    elements.historyList.querySelectorAll('.history-item:not(.js-history-item-template)').forEach(item => item.remove());

                    if (chats && chats.length > 0) {
                        elements.noHistoryMessage.classList.add('hidden'); // 「履歴なし」メッセージを隠す
                        // ヘッダータイトルにソート順を表示
                        const sortOrderText = state.settings.historySortOrder === 'createdAt' ? '作成順' : '更新順';
                        elements.historyTitle.textContent = `履歴一覧 (${sortOrderText})`;

                        chats.forEach(chat => {
                            const li = elements.historyItemTemplate.cloneNode(true); // テンプレートを複製
                            li.classList.remove('js-history-item-template'); // テンプレートクラスを削除
                            li.dataset.chatId = chat.id; // チャットIDをデータ属性に設定

                            const titleText = chat.title || `履歴 ${chat.id}`;
                            const titleEl = li.querySelector('.history-item-title');
                            titleEl.textContent = titleText;
                            titleEl.title = titleText; // ホバーで全文表示

                            li.querySelector('.created-date').textContent = `作成: ${this.formatDate(chat.createdAt)}`;
                            li.querySelector('.updated-date').textContent = `更新: ${this.formatDate(chat.updatedAt)}`;

                            // クリックイベント (アクションボタン以外)
                            li.onclick = (event) => {
                                // アクションボタンがクリックされた場合は何もしない
                                if (!event.target.closest('.history-item-actions button')) {
                                    appLogic.loadChat(chat.id);
                                    this.showScreen('chat'); // チャット画面へ遷移
                                }
                            };

                            // 各アクションボタンのイベントリスナー
                            li.querySelector('.js-edit-title-btn').onclick = (e) => { e.stopPropagation(); appLogic.editHistoryTitle(chat.id, titleEl); };
                            li.querySelector('.js-export-btn').onclick = (e) => { e.stopPropagation(); appLogic.exportChat(chat.id, titleText); };
                            li.querySelector('.js-duplicate-btn').onclick = (e) => { e.stopPropagation(); appLogic.duplicateChat(chat.id); };
                            li.querySelector('.js-delete-btn').onclick = (e) => { e.stopPropagation(); appLogic.confirmDeleteChat(chat.id, titleText); };

                            elements.historyList.appendChild(li); // リストに追加
                        });
                    } else {
                        elements.noHistoryMessage.classList.remove('hidden'); // 「履歴なし」メッセージを表示
                        elements.historyTitle.textContent = '履歴一覧'; // ソート順なしのタイトル
                    }
                } catch (error) {
                    console.error("履歴リストのレンダリングエラー:", error);
                    elements.noHistoryMessage.textContent = "履歴の読み込み中にエラーが発生しました。";
                    elements.noHistoryMessage.classList.remove('hidden');
                    elements.historyTitle.textContent = '履歴一覧';
                }
            },

            // --- 背景画像UIヘルパー ---
            // 既存のオブジェクトURLを破棄
            revokeExistingObjectUrl() {
                if (state.backgroundImageUrl) {
                    try {
                        URL.revokeObjectURL(state.backgroundImageUrl);
                        console.log("以前の背景URLを破棄:", state.backgroundImageUrl);
                    } catch (e) {
                        console.error("オブジェクトURLの破棄エラー:", e);
                    }
                    state.backgroundImageUrl = null;
                }
            },
            // 背景画像設定UIを更新
            updateBackgroundSettingsUI() {
                if (!elements.backgroundThumbnail || !elements.deleteBackgroundBtn) return;
                if (state.backgroundImageUrl) {
                    elements.backgroundThumbnail.src = state.backgroundImageUrl;
                    elements.backgroundThumbnail.classList.remove('hidden');
                    elements.deleteBackgroundBtn.classList.remove('hidden');
                } else {
                    elements.backgroundThumbnail.src = '';
                    elements.backgroundThumbnail.classList.add('hidden');
                    elements.deleteBackgroundBtn.classList.add('hidden');
                }
            },
            // ------------------------------------

            // 設定をUIに適用
            applySettingsToUI() {
                elements.apiKeyInput.value = state.settings.apiKey || '';
                elements.modelNameSelect.value = state.settings.modelName || DEFAULT_MODEL;
                elements.streamingOutputCheckbox.checked = state.settings.streamingOutput;
                elements.streamingSpeedInput.value = state.settings.streamingSpeed ?? DEFAULT_STREAMING_SPEED;
                elements.systemPromptDefaultTextarea.value = state.settings.systemPrompt || ''; // デフォルト用
                elements.temperatureInput.value = state.settings.temperature === null ? '' : state.settings.temperature;
                elements.maxTokensInput.value = state.settings.maxTokens === null ? '' : state.settings.maxTokens;
                elements.topKInput.value = state.settings.topK === null ? '' : state.settings.topK;
                elements.topPInput.value = state.settings.topP === null ? '' : state.settings.topP;
                elements.dummyUserInput.value = state.settings.dummyUser || '';
                elements.dummyModelInput.value = state.settings.dummyModel || '';
                elements.concatDummyModelCheckbox.checked = state.settings.concatDummyModel;
                elements.additionalModelsTextarea.value = state.settings.additionalModels || '';
                elements.pseudoStreamingCheckbox.checked = state.settings.pseudoStreaming;
                elements.enterToSendCheckbox.checked = state.settings.enterToSend;
                elements.historySortOrderSelect.value = state.settings.historySortOrder || 'updatedAt';
                elements.darkModeToggle.checked = state.settings.darkMode; // ダークモードチェックボックスに状態を適用
                elements.fontFamilyInput.value = state.settings.fontFamily || ''; // フォント設定を適用
                elements.hideSystemPromptToggle.checked = state.settings.hideSystemPromptInChat; // SP非表示設定

                // ユーザー指定モデルをコンボボックスに追加
                this.updateUserModelOptions();

                this.updateBackgroundSettingsUI(); // 背景画像UI要素を更新
                this.applyDarkMode(); // 読み込み/更新された設定を反映してテーマを適用 (チェックボックス設定後)
                this.applyFontFamily(); // フォント設定を適用
                this.toggleSystemPromptVisibility(); // SP表示/非表示を適用
            },

            // ユーザー指定モデルをコンボボックスに反映
            updateUserModelOptions() {
                const group = elements.userDefinedModelsGroup;
                group.innerHTML = ''; // 一旦クリア
                const models = (state.settings.additionalModels || '')
                    .split(',')
                    .map(m => m.trim())
                    .filter(m => m !== ''); // カンマ区切りで分割し、空要素を除去

                if (models.length > 0) {
                    group.disabled = false; // optgroupを有効化
                    models.forEach(modelId => {
                        const option = document.createElement('option');
                        option.value = modelId;
                        option.textContent = modelId;
                        group.appendChild(option);
                    });
                    // 現在選択中のモデルがユーザー指定モデルに含まれていれば、それを選択状態にする
                    if (models.includes(state.settings.modelName)) {
                        elements.modelNameSelect.value = state.settings.modelName;
                    }
                } else {
                    group.disabled = true; // モデルがなければoptgroupを無効化
                }
            },

            // ダークモードを適用
            applyDarkMode() {
                const isDark = state.settings.darkMode;
                document.body.classList.toggle('dark-mode', isDark);
                // OS設定の上書き用クラス (ダークモードでない場合)
                document.body.classList.toggle('light-mode-forced', !isDark);
                elements.themeColorMeta.content = isDark ? DARK_THEME_COLOR : LIGHT_THEME_COLOR;
                console.log(`ダークモード ${isDark ? '有効' : '無効'}. テーマカラー: ${elements.themeColorMeta.content}`);
            },

            // フォント設定を適用
            applyFontFamily() {
                const customFont = state.settings.fontFamily?.trim();
                const fontFamilyToApply = customFont ? customFont : DEFAULT_FONT_FAMILY;
                document.documentElement.style.setProperty('--font-family', fontFamilyToApply);
                console.log(`フォント適用: ${fontFamilyToApply}`);
            },

            // --- システムプロンプトUI更新 ---
            updateSystemPromptUI() {
                elements.systemPromptEditor.value = state.currentSystemPrompt;
                // 編集中でない場合、detailsタグを閉じる
                if (!state.isEditingSystemPrompt) {
                    elements.systemPromptDetails.removeAttribute('open');
                }
                // テキストエリアの高さを調整
                this.adjustTextareaHeight(elements.systemPromptEditor, 200);
                // 表示/非表示を制御
                this.toggleSystemPromptVisibility();
            },
            // システムプロンプトエリアの表示/非表示を切り替え
            toggleSystemPromptVisibility() {
                const shouldHide = state.settings.hideSystemPromptInChat;
                elements.systemPromptArea.classList.toggle('hidden', shouldHide);
                console.log(`システムプロンプト表示エリア ${shouldHide ? '非表示' : '表示'}`);
            },
            // --------------------------------

            // 画面を表示 (スワイプアニメーション + inert対応 + 戻るボタン対応)
            showScreen(screenName, fromPopState = false) {
                // 編集中ならキャンセル
                if (state.editingMessageIndex !== null) {
                     const messageElement = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                     if (messageElement) { // 要素が存在する場合のみキャンセル処理
                        appLogic.cancelEditMessage(state.editingMessageIndex, messageElement);
                     } else {
                        state.editingMessageIndex = null; // 要素が見つからない場合はインデックスのみリセット
                     }
                }
                // システムプロンプト編集中ならキャンセル
                if (state.isEditingSystemPrompt) {
                    appLogic.cancelEditSystemPrompt();
                }

                // 現在の画面と同じなら何もしない
                if (screenName === state.currentScreen) {
                    // console.log(`showScreen: Already on screen ${screenName}.`); // ログ削減
                    return;
                }

                const allScreens = [elements.chatScreen, elements.historyScreen, elements.settingsScreen];
                let activeScreen = null;

                // fromPopStateがfalseの場合のみ履歴操作を行う (UI操作時)
                if (!fromPopState) {
                    if (screenName === 'history' || screenName === 'settings') {
                        // 履歴/設定画面への遷移時は履歴を追加
                        history.pushState({ screen: screenName }, '', `#${screenName}`);
                        console.log(`Pushed state: ${screenName}`);
                    } else if (screenName === 'chat') {
                        // チャット画面へ戻る遷移 (通常はUIの戻るボタンやpopstateで処理される想定だが、
                        // 直接 showScreen('chat') が呼ばれた場合も考慮)
                        // ここではURLハッシュのみ更新し、履歴スタックは変更しない
                        history.replaceState({ screen: 'chat' }, '', '#chat');
                        console.log(`Replaced state: ${screenName}`);
                    }
                } else {
                    // popstateイベント経由の場合は履歴操作は行わない
                    console.log(`showScreen called from popstate for ${screenName}`);
                }

                // まず全ての画面を非アクティブ＆inert状態にする
                allScreens.forEach(screen => {
                    screen.classList.remove('active');
                    screen.inert = true; // 非アクティブ画面は操作不可に
                });

                // ターゲット画面に応じてtransformとアクティブ設定
                if (screenName === 'chat') {
                    activeScreen = elements.chatScreen;
                    elements.chatScreen.style.transform = 'translateX(0)';
                    elements.historyScreen.style.transform = 'translateX(-100%)';
                    elements.settingsScreen.style.transform = 'translateX(100%)';
                    requestAnimationFrame(() => {
                        this.updateSystemPromptUI();
                        this.adjustTextareaHeight();
                        this.scrollToBottom();
                    });
                } else if (screenName === 'history') {
                    activeScreen = elements.historyScreen;
                    elements.chatScreen.style.transform = 'translateX(100%)';
                    elements.historyScreen.style.transform = 'translateX(0)';
                    elements.settingsScreen.style.transform = 'translateX(200%)';
                    this.renderHistoryList();
                } else if (screenName === 'settings') {
                    activeScreen = elements.settingsScreen;
                    elements.chatScreen.style.transform = 'translateX(-100%)';
                    elements.historyScreen.style.transform = 'translateX(-200%)';
                    elements.settingsScreen.style.transform = 'translateX(0)';
                    this.applySettingsToUI();
                }

                // アニメーション適用とアクティブ化
                requestAnimationFrame(() => {
                    allScreens.forEach(screen => {
                        screen.style.transition = 'transform 0.3s ease-in-out';
                    });
                    if (activeScreen) {
                        activeScreen.inert = false; // アクティブ画面は操作可能に
                        activeScreen.classList.add('active');
                    }
                });

                // 現在の画面名をstateに保存
                state.currentScreen = screenName;
                console.log(`Navigated to screen: ${screenName}`);
            },

            // 送信状態を設定
            setSendingState(sending) {
                state.isSending = sending;
                if (sending) {
                    elements.sendButton.textContent = '止'; // ボタンテキスト変更
                    elements.sendButton.classList.add('sending'); // スタイル変更用クラス
                    elements.sendButton.title = "停止";
                    elements.sendButton.disabled = false; // 停止ボタンは常に有効
                    elements.userInput.disabled = true; // 入力欄無効化
                    elements.loadingIndicator.classList.remove('hidden'); // ローディング表示
                    elements.loadingIndicator.setAttribute('aria-live', 'polite'); // スクリーンリーダー用
                    // システムプロンプト編集も不可にする
                    elements.systemPromptDetails.style.pointerEvents = 'none';
                    elements.systemPromptDetails.style.opacity = '0.7';
                } else {
                    elements.sendButton.textContent = '送';
                    elements.sendButton.classList.remove('sending');
                    elements.sendButton.title = "送信";
                    // 入力が空なら送信ボタン無効化
                    elements.sendButton.disabled = elements.userInput.value.trim() === '';
                    elements.userInput.disabled = false; // 入力欄有効化
                    elements.loadingIndicator.classList.add('hidden'); // ローディング非表示
                    elements.loadingIndicator.removeAttribute('aria-live');
                    // システムプロンプト編集を可能にする
                    elements.systemPromptDetails.style.pointerEvents = '';
                    elements.systemPromptDetails.style.opacity = '';
                }
            },

            // テキストエリアの高さを自動調整
            adjustTextareaHeight(textarea = elements.userInput, maxHeight = TEXTAREA_MAX_HEIGHT) {
                textarea.style.height = 'auto'; // 一旦高さをリセット
                const scrollHeight = textarea.scrollHeight;
                // 最大高さを超えないように設定
                textarea.style.height = Math.min(scrollHeight, maxHeight) + 'px';
                // メイン入力欄の場合、送信ボタンの有効/無効を更新
                if (textarea === elements.userInput && !state.isSending) {
                    elements.sendButton.disabled = textarea.value.trim() === '';
                }
            },

            // --- カスタムダイアログ関数 ---
            // ダイアログを表示し、閉じられるまで待機
            showCustomDialog(dialogElement, focusElement) {
                return new Promise((resolve) => {
                    const closeListener = () => {
                        dialogElement.removeEventListener('close', closeListener);
                        resolve(dialogElement.returnValue); // 閉じたときの値を返す
                    };
                    dialogElement.addEventListener('close', closeListener);
                    dialogElement.showModal(); // モーダルダイアログとして表示
                    // 指定された要素にフォーカス
                    if (focusElement) {
                        requestAnimationFrame(() => { focusElement.focus(); });
                    }
                });
            },
            // アラートダイアログ表示
            async showCustomAlert(message) {
                elements.alertMessage.textContent = message;
                 // ボタンのイベントリスナーが重複しないように複製して置き換え
                 const newOkBtn = elements.alertOkBtn.cloneNode(true);
                 elements.alertOkBtn.parentNode.replaceChild(newOkBtn, elements.alertOkBtn);
                 elements.alertOkBtn = newOkBtn;
                elements.alertOkBtn.onclick = () => elements.alertDialog.close('ok');
                await this.showCustomDialog(elements.alertDialog, elements.alertOkBtn);
            },
            // 確認ダイアログ表示
            async showCustomConfirm(message) {
                elements.confirmMessage.textContent = message;
                 // ボタンのイベントリスナーが重複しないように複製して置き換え
                 const newOkBtn = elements.confirmOkBtn.cloneNode(true);
                 elements.confirmOkBtn.parentNode.replaceChild(newOkBtn, elements.confirmOkBtn);
                 elements.confirmOkBtn = newOkBtn;
                 const newCancelBtn = elements.confirmCancelBtn.cloneNode(true);
                 elements.confirmCancelBtn.parentNode.replaceChild(newCancelBtn, elements.confirmCancelBtn);
                 elements.confirmCancelBtn = newCancelBtn;

                elements.confirmOkBtn.onclick = () => elements.confirmDialog.close('ok');
                elements.confirmCancelBtn.onclick = () => elements.confirmDialog.close('cancel');
                const result = await this.showCustomDialog(elements.confirmDialog, elements.confirmOkBtn);
                return result === 'ok'; // OKが押されたか
            },
            // プロンプトダイアログ表示
            async showCustomPrompt(message, defaultValue = '') {
                elements.promptMessage.textContent = message;
                elements.promptInput.value = defaultValue;
                 // ボタンと入力欄のイベントリスナーが重複しないように複製して置き換え
                 const newOkBtn = elements.promptOkBtn.cloneNode(true);
                 elements.promptOkBtn.parentNode.replaceChild(newOkBtn, elements.promptOkBtn);
                 elements.promptOkBtn = newOkBtn;
                 const newCancelBtn = elements.promptCancelBtn.cloneNode(true);
                 elements.promptCancelBtn.parentNode.replaceChild(newCancelBtn, elements.promptCancelBtn);
                 elements.promptCancelBtn = newCancelBtn;
                 const newPromptInput = elements.promptInput.cloneNode(true);
                 elements.promptInput.parentNode.replaceChild(newPromptInput, elements.promptInput);
                 elements.promptInput = newPromptInput;

                // EnterキーでOKボタンをクリックする処理
                const enterHandler = (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        elements.promptOkBtn.click();
                    }
                };
                elements.promptInput.addEventListener('keypress', enterHandler);

                elements.promptOkBtn.onclick = () => elements.promptDialog.close(elements.promptInput.value); // OK時は入力値を返す
                elements.promptCancelBtn.onclick = () => elements.promptDialog.close(''); // キャンセル時は空文字列 ('') を渡す

                // ダイアログが閉じたらEnterキーリスナーを削除
                const closeHandler = () => {
                    elements.promptInput.removeEventListener('keypress', enterHandler);
                    elements.promptDialog.removeEventListener('close', closeHandler);
                };
                 elements.promptDialog.addEventListener('close', closeHandler);

                const result = await this.showCustomDialog(elements.promptDialog, elements.promptInput);
                return result; // 入力値またはnullを返す
            }
        };

        // --- APIユーティリティ (apiUtils) ---
        const apiUtils = {
            // Gemini APIを呼び出す
            async callGeminiApi(messagesForApi, generationConfig, systemInstruction) {
                if (!state.settings.apiKey) {
                    throw new Error("APIキーが設定されていません。");
                }
                // 新しいリクエストのためにAbortControllerを作成
                state.abortController = new AbortController();
                const { signal } = state.abortController;

                const useStreaming = state.settings.streamingOutput;
                const usePseudo = state.settings.pseudoStreaming;
                const model = state.settings.modelName || DEFAULT_MODEL;
                const apiKey = state.settings.apiKey;

                // ストリーミング/疑似ストリーミング/非ストリーミングでエンドポイントを切り替え
                let endpointMethod = useStreaming
                    ? (usePseudo ? 'generateContent?alt=sse&' : 'streamGenerateContent?alt=sse&')
                    : 'generateContent?';
                console.log(`使用モード: ${useStreaming ? (usePseudo ? '疑似ストリーミング' : 'リアルタイムストリーミング') : '非ストリーミング'}`);

                const endpoint = `${GEMINI_API_BASE_URL}${model}:${endpointMethod}key=${apiKey}`;

                // リクエストボディを作成
                const requestBody = {
                    contents: messagesForApi,
                    // generationConfigが空でない場合のみ追加
                    ...(Object.keys(generationConfig).length > 0 && { generationConfig }),
                    // systemInstructionが存在する場合のみ追加 (systemInstructionはオブジェクト形式)
                    ...(systemInstruction && systemInstruction.parts && systemInstruction.parts.length > 0 && systemInstruction.parts[0].text && { systemInstruction }),
                    // 安全性設定 (全てブロック解除)
                     safetySettings : [
                         { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                         { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                         { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
                         { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                     ],
                };

                console.log("Geminiへの送信データ:", JSON.stringify(requestBody, null, 2));
                console.log("ターゲットエンドポイント:", endpoint);

                try {
                    const response = await fetch(endpoint, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestBody),
                        signal // AbortControllerのシグナルを渡す
                    });

                    // エラーレスポンス処理
                    if (!response.ok) {
                        let errorMsg = `APIエラー (${response.status}): ${response.statusText}`;
                        try {
                            // エラーレスポンスのボディをJSONとしてパース試行
                            const errorData = await response.json();
                            console.error("APIエラーレスポンスボディ:", errorData);
                            if (errorData.error && errorData.error.message) {
                                errorMsg = `APIエラー (${response.status}): ${errorData.error.message}`;
                            }
                        } catch (e) {
                            console.error("APIエラーレスポンスボディのパース失敗:", e);
                        }
                        throw new Error(errorMsg);
                    }
                    // 成功レスポンスを返す
                    return response;
                } catch (error) {
                    // AbortErrorの場合、キャンセルされたことを示すエラーを投げる
                    if (error.name === 'AbortError') {
                        throw new Error("リクエストがキャンセルされました。");
                    } else {
                        // その他のネットワークエラーなど
                        throw error;
                    }
                }
            },

            // ストリーミングレスポンスを処理
            async handleStreamingResponse(response) {
                 if (!response.body) {
                     throw new Error("レスポンスボディがありません。");
                 }
                 // レスポンスボディをテキストとして読み取るリーダーを取得
                 const reader = response.body.pipeThrough(new TextDecoderStream()).getReader();
                 let buffer = ''; // 未処理のチャンクを保持するバッファ
                 let lastCandidateInfo = null; // 最後の候補者情報 (finishReasonなど)
                 const textChunks = []; // 受信したテキストチャンクの配列
                 let isCancelled = false; // キャンセルされたかどうかのフラグ

                 try {
                     while (true) {
                         // キャンセルシグナルをチェック
                         if (state.abortController?.signal.aborted && !isCancelled) {
                             isCancelled = true;
                             console.log("ストリーミング中に中断シグナルを検出");
                             await reader.cancel("User aborted"); // リーダーをキャンセル
                             throw new Error("リクエストがキャンセルされました。");
                         }

                         let readResult;
                         try {
                             // データを読み取る
                             readResult = await reader.read();
                         } catch (readError) {
                             // 読み取り中にエラーが発生した場合 (キャンセル含む)
                             if (readError.name === 'AbortError' || readError.message === "User aborted" || readError.message.includes("aborted")) {
                                 if (!isCancelled) { // まだキャンセルされていなければエラーとして投げる
                                     isCancelled = true;
                                     throw new Error("リクエストがキャンセルされました。");
                                 }
                                 break; // キャンセル済みならループを抜ける
                             }
                             throw readError; // その他の読み取りエラー
                         }

                         const { value, done } = readResult;

                         if (done) { // ストリーム終了
                             console.log("ストリーム終了 (done)");
                             // バッファに残っているデータを処理
                             if (buffer.trim()) {
                                 processBuffer(buffer, true);
                             }
                             break; // ループを抜ける
                         }

                         // 受信したデータをバッファに追加
                         buffer += value;
                         // バッファを処理してSSEメッセージを抽出
                         buffer = processBuffer(buffer, false);
                     } // whileループ終了

                     // 最終的なメタデータを取得
                     const finishReason = lastCandidateInfo?.finishReason;
                     const safetyRatings = lastCandidateInfo?.safetyRatings;

                     // コンテンツなしで終了した場合の警告
                     if (!isCancelled && textChunks.length === 0 && (!finishReason || finishReason === "STOP")) {
                         console.warn("ストリーミングがコンテンツなしで終了しました。");
                     }

                     console.log(`ストリーム処理終了。キャンセル: ${isCancelled}, 終了理由: ${finishReason}`);
                     // 結果オブジェクトを返す
                     return {
                         textChunks,
                         finishReason: isCancelled ? 'ABORTED' : finishReason, // キャンセルされた場合は理由をABORTEDに
                         safetyRatings
                     };
                 } catch (error) {
                     // ストリーム処理中のエラー
                     console.error("ストリームの読み取り/処理エラー:", error);
                     // エラー発生時でも部分的なチャンクがあれば保持
                     const partialChunksOnError = (error.message !== "リクエストがキャンセルされました.") ? textChunks : [];
                     throw new Error(`ストリーミング処理エラー: ${error.message || error}`, { cause: { originalError: error, partialChunks: partialChunksOnError } });
                 } finally {
                     // ループ終了後、リーダーがまだ閉じておらず、キャンセルもされていない場合、クリーンアップのためにキャンセルを試みる
                     if (!reader.closed && !isCancelled) {
                         console.warn("リーダーがループ後に閉じていません。クリーンアップキャンセルを試みます。");
                         try { await reader.cancel("Cleanup cancellation"); } catch(e) { console.error("クリーンアップキャンセル中のエラー:", e); }
                     }
                 }

                 // SSEメッセージを処理する内部関数
                 function processBuffer(currentBuffer, isFinalChunk) {
                     let remainingBuffer = currentBuffer;
                     while (true) {
                         const newlineIndex = remainingBuffer.indexOf('\n');
                         if (newlineIndex === -1) { // 改行が見つからない
                             // 最後のチャンクで、バッファが 'data: ' で始まる場合、それを処理
                             if (isFinalChunk && remainingBuffer.trim().startsWith('data: ')) {
                                 parseSseData(remainingBuffer.trim().substring(6));
                                 remainingBuffer = ''; // バッファをクリア
                             }
                             break; // ループを抜ける
                         }
                         // 1行取り出す
                         const line = remainingBuffer.substring(0, newlineIndex).trim();
                         // 残りのバッファを更新
                         remainingBuffer = remainingBuffer.substring(newlineIndex + 1);

                         if (line.startsWith('data: ')) { // データ行の場合
                             parseSseData(line.substring(6)); // 'data: ' を除いたJSON部分をパース
                         } else if (line !== '') { // 空行以外の非データ行は無視 (警告表示)
                             console.warn("データ以外のSSE行を無視:", line);
                         }
                     }
                     return remainingBuffer; // 処理しきれなかった部分を返す
                 }

                 // SSEデータ (JSON) をパースする内部関数
                 function parseSseData(jsonString) {
                     try {
                         const chunkData = JSON.parse(jsonString);
                         // エラーメッセージが含まれている場合
                         if (chunkData.error) {
                             console.error("ストリーム内のエラーメッセージ:", chunkData.error);
                             const errorMsg = `モデルエラー: ${chunkData.error.message || JSON.stringify(chunkData.error)}`;
                             lastCandidateInfo = { error: chunkData.error, finishReason: 'ERROR' }; // 最後の情報をエラーとして記録
                             throw new Error(errorMsg); // エラーを投げてストリーム処理を中断
                         }
                         // 候補者データが含まれている場合
                         if (chunkData.candidates && chunkData.candidates.length > 0) {
                             lastCandidateInfo = chunkData.candidates[0]; // 最後の候補者情報を更新
                             const textChunk = lastCandidateInfo?.content?.parts?.[0]?.text;
                             if (typeof textChunk === 'string') {
                                 textChunks.push(textChunk); // テキストチャンクを配列に追加
                             } else {
                                 console.log("テキストなしのストリームチャンク候補:", chunkData);
                             }
                         } else if (chunkData.promptFeedback) { // プロンプトフィードバックの場合 (ブロックなど)
                             console.warn("ストリーム内のプロンプトフィードバック:", chunkData.promptFeedback);
                             // 安全性評価などを最後の情報として記録
                             lastCandidateInfo = { finishReason: 'SAFETY', safetyRatings: chunkData.promptFeedback.safetyRatings };
                         } else { // その他の予期しないデータ
                             console.log("候補/エラー以外のストリームチャンク:", chunkData);
                         }
                     } catch (parseError) {
                         // JSONパースエラーは警告表示してスキップ
                         console.warn("ストリーム内の不正なJSONをスキップ:", jsonString, parseError);
                     }
                 }
            }
        };

        // --- アプリケーションロジック (appLogic) ---
        const appLogic = {
            // アプリ初期化
            async initializeApp() {
                // marked.jsの設定
                if (typeof marked !== 'undefined') {
                    marked.setOptions({
                        breaks: true, // 改行を<br>に変換
                        gfm: true, // GitHub Flavored Markdown有効化
                        sanitize: true, // HTMLサニタイズ (XSS対策)
                        smartypants: false // スマートクォートなどを無効化
                    });
                    console.log("Marked.js設定完了");
                } else {
                    console.error("Marked.jsライブラリが読み込まれていません！");
                }
                // バージョン表示
                elements.appVersionSpan.textContent = APP_VERSION;
                // PWAインストールプロンプトのデフォルト動作を抑制
                window.addEventListener('beforeinstallprompt', (event) => {
                    event.preventDefault();
                    console.log('beforeinstallpromptイベントを抑制しました。');
                    // ここで独自のインストールボタンを表示するロジックを追加可能
                });

                // 初期画面をチャットに設定 (UI表示のみ、state更新と履歴操作は後で)
                uiUtils.showScreen('chat');

                registerServiceWorker(); // Service Worker登録

                try {
                    await dbUtils.openDB(); // DBを開く
                    await dbUtils.loadSettings(); // 設定を読み込む (stateに反映)

                    // 読み込んだ設定に基づいて初期テーマとフォントを適用
                    uiUtils.applyDarkMode();
                    uiUtils.applyFontFamily();

                    // 読み込んだ設定に基づいて背景画像を適用
                    if (state.settings.backgroundImageBlob instanceof Blob) {
                        uiUtils.revokeExistingObjectUrl(); // 既存URLがあれば破棄
                        try {
                             state.backgroundImageUrl = URL.createObjectURL(state.settings.backgroundImageBlob);
                             document.documentElement.style.setProperty('--chat-background-image', `url(${state.backgroundImageUrl})`);
                             console.log("読み込んだBlobから背景画像を適用しました。");
                        } catch (e) {
                             console.error("背景画像のオブジェクトURL作成エラー:", e);
                             document.documentElement.style.setProperty('--chat-background-image', 'none');
                        }
                    } else {
                        // 背景画像がない場合はスタイルをリセット
                        document.documentElement.style.setProperty('--chat-background-image', 'none');
                    }

                    // 読み込んだ全設定をUIフィールドに適用
                    uiUtils.applySettingsToUI();

                    // 最新のチャットを読み込むか、新規チャットを開始
                    const chats = await dbUtils.getAllChats(state.settings.historySortOrder);
                    if (chats && chats.length > 0) {
                        await this.loadChat(chats[0].id); // 最新チャットを読み込み
                    } else {
                        this.startNewChat(); // 履歴がなければ新規チャット
                    }

                    // 初期状態を履歴スタックに設定 (loadChat/startNewChatの後)
                    history.replaceState({ screen: 'chat' }, '', '#chat');
                    state.currentScreen = 'chat'; // stateも初期化
                    console.log("Initial history state set to #chat");

                } catch (error) {
                    console.error("初期化失敗:", error);
                    await uiUtils.showCustomAlert(`アプリの初期化に失敗しました: ${error}`);
                    // 致命的なエラーの場合はアプリ内容をエラー表示に置き換え
                    elements.appContainer.innerHTML = `<p style="padding: 20px; text-align: center; color: red;">アプリの起動に失敗しました。</p>`;
                } finally {
                    // max-widthの固定幅をpxで算出
                    updateMessageMaxWidthVar();
                    // イベントリスナーを設定 (初期履歴設定後)
                    this.setupEventListeners();
                    // ズーム状態を初期化
                    this.updateZoomState();
                    // UI調整
                    uiUtils.adjustTextareaHeight();
                    uiUtils.setSendingState(false); // 送信状態をリセット
                }
            },

            // イベントリスナーを設定
            setupEventListeners() {
                // ナビゲーションボタン
                elements.gotoHistoryBtn.addEventListener('click', () => uiUtils.showScreen('history'));
                elements.gotoSettingsBtn.addEventListener('click', () => uiUtils.showScreen('settings'));
                // 戻るボタンは history.back() を使用
                elements.backToChatFromHistoryBtn.addEventListener('click', () => history.back());
                elements.backToChatFromSettingsBtn.addEventListener('click', () => history.back());

                // チャットアクション
                elements.newChatBtn.addEventListener('click', async () => {
                    // 現在のチャットを保存するか確認
                    const confirmed = await uiUtils.showCustomConfirm("現在のチャットを保存して新規チャットを開始しますか？");
                    if (confirmed) this.confirmStartNewChat();
                });
                elements.sendButton.addEventListener('click', () => {
                    if (state.isSending) this.abortRequest(); // 送信中なら中断
                    else this.handleSend(); // そうでなければ送信
                });
                elements.userInput.addEventListener('input', () => uiUtils.adjustTextareaHeight()); // 入力時に高さ調整
                elements.userInput.addEventListener('keypress', (e) => {
                    // Enterで送信 (Shift+Enterは除く)
                    if (state.settings.enterToSend && e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault(); // デフォルトの改行動作を抑制
                        if (!elements.sendButton.disabled) this.handleSend(); // 送信ボタンが有効なら送信
                    }
                });

                // システムプロンプトUIアクション
                elements.systemPromptDetails.addEventListener('toggle', (event) => {
                    if (event.target.open) {
                        // 開いたときに編集モードに入る
                        this.startEditSystemPrompt();
                    } else if (state.isEditingSystemPrompt) {
                        // 閉じられたときに編集中だったらキャンセル
                        this.cancelEditSystemPrompt();
                    }
                });
                elements.saveSystemPromptBtn.addEventListener('click', () => this.saveCurrentSystemPrompt());
                elements.cancelSystemPromptBtn.addEventListener('click', () => this.cancelEditSystemPrompt());
                elements.systemPromptEditor.addEventListener('input', () => {
                    uiUtils.adjustTextareaHeight(elements.systemPromptEditor, 200); // 高さ調整
                });

                // 履歴アクション
                elements.importHistoryBtn.addEventListener('click', () => elements.importHistoryInput.click());
                elements.importHistoryInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) this.handleHistoryImport(file);
                    event.target.value = null; // 同じファイルを選択できるようにリセット
                });

                // 設定アクション
                elements.saveSettingsBtns.forEach(button => {
                    button.addEventListener('click', () => this.saveSettings());
                });
                elements.updateAppBtn.addEventListener('click', () => this.updateApp());
                elements.clearDataBtn.addEventListener('click', () => this.confirmClearAllData());

                // ダークモード切り替えリスナー
                elements.darkModeToggle.addEventListener('change', () => {
                    state.settings.darkMode = elements.darkModeToggle.checked; // stateを即時更新
                    uiUtils.applyDarkMode(); // テーマを即時適用
                    // 注意: 変更は「設定を保存」ボタンクリック時にDBに保存される
                });

                 // 背景画像ボタンリスナー
                elements.uploadBackgroundBtn.addEventListener('click', () => elements.backgroundImageInput.click()); // ファイル選択ダイアログを開く
                elements.backgroundImageInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file) this.handleBackgroundImageUpload(file);
                    event.target.value = null; // 同じファイルを選択できるようにリセット
                });
                elements.deleteBackgroundBtn.addEventListener('click', () => this.confirmDeleteBackgroundImage());

                // SP非表示トグルリスナー
                elements.hideSystemPromptToggle.addEventListener('change', () => {
                    state.settings.hideSystemPromptInChat = elements.hideSystemPromptToggle.checked;
                    uiUtils.toggleSystemPromptVisibility(); // UIを即時更新
                    // 注意: DBへの保存は「設定を保存」ボタンで行われる
                });
                
                // --- メッセージクリックで操作ボックス表示/非表示 ---
                elements.messageContainer.addEventListener('click', (event) => {
                    const clickedMessage = event.target.closest('.message');

                    // 操作ボックス内のボタンがクリックされた場合は何もしない
                    if (event.target.closest('.message-actions button, .message-cascade-controls button')) {
                        return;
                    }

                    // クリックされたのがメッセージ要素の場合
                    if (clickedMessage) {
                        // すでに表示されている他のメッセージがあれば非表示にする
                        const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                        if (currentlyShown && currentlyShown !== clickedMessage) {
                            currentlyShown.classList.remove('show-actions');
                        }

                        // クリックされたメッセージの表示状態をトグル
                        // (編集中はトグルしないようにする)
                        if (!clickedMessage.classList.contains('editing')) {
                            clickedMessage.classList.toggle('show-actions');
                        }
                    } else {
                        // メッセージコンテナ内だがメッセージ要素以外がクリックされた場合
                        // (メッセージ間の余白など)
                        // 表示中の操作ボックスがあれば非表示にする
                        const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                        if (currentlyShown) {
                            currentlyShown.classList.remove('show-actions');
                        }
                    }
                });

                // --- メッセージコンテナ外クリックで操作ボックスを非表示 ---
                document.body.addEventListener('click', (event) => {
                    // クリックがメッセージコンテナの外で発生した場合
                    if (!elements.messageContainer.contains(event.target)) {
                        // 表示中の操作ボックスがあれば非表示にする
                        const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                        if (currentlyShown) {
                            currentlyShown.classList.remove('show-actions');
                        }
                    }
                    // メッセージコンテナ内のクリックは上記のリスナーで処理される
                }, true); 

                // スワイプイベントリスナー (チャット画面のみ)
                // passive: false にして preventDefault を呼べるようにする (必要に応じて)
                elements.chatScreen.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: true }); // passive: trueのまま、moveで必要なら変更
                elements.chatScreen.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false }); // 横スワイプ判定時にpreventDefaultするため false
                elements.chatScreen.addEventListener('touchend', this.handleTouchEnd.bind(this));

                // VisualViewport APIリスナー (ズーム状態監視)
                if ('visualViewport' in window) {
                    window.visualViewport.addEventListener('resize', this.updateZoomState.bind(this));
                    window.visualViewport.addEventListener('scroll', this.updateZoomState.bind(this));
                } else {
                    console.warn("VisualViewport API is not supported in this browser.");
                    // フォールバックが必要な場合の処理 (例: ピンチジェスチャーを簡易的に検出するなど)
                }

                // popstate イベントリスナー (戻るボタン/ジェスチャー対応)
                window.addEventListener('popstate', this.handlePopState.bind(this));
                console.log("popstate listener added.");
            },

            // popstateイベントハンドラ (戻るボタン/ジェスチャー)
            handlePopState(event) {
                // 履歴スタックから遷移先の画面名を取得、なければチャット画面
                const targetScreen = event.state?.screen || 'chat';
                console.log(`popstate event fired: Navigating to screen '${targetScreen}' from history state.`);
                // showScreenを呼び出す (fromPopState = true を渡して履歴操作を抑制)
                uiUtils.showScreen(targetScreen, true);
            },

            // ズーム状態を更新
            updateZoomState() {
                if ('visualViewport' in window) {
                    // スケールが閾値より大きい場合をズームとみなす
                    const newZoomState = window.visualViewport.scale > ZOOM_THRESHOLD;
                    if (state.isZoomed !== newZoomState) {
                        state.isZoomed = newZoomState;
                        console.log(`Zoom state updated: ${state.isZoomed}`);
                        // ズーム状態に応じてbodyにクラスを追加/削除
                        document.body.classList.toggle('zoomed', state.isZoomed);
                    }
                }
            },


            // --- スワイプ処理 (ズーム対応) ---
            handleTouchStart(event) {
                // マルチタッチ(ピンチ操作など)やズーム中はスワイプ開始点を記録しない
                if (event.touches.length > 1 || state.isZoomed) {
                    state.touchStartX = 0; // 開始点をリセットしてスワイプ判定を無効化
                    state.touchStartY = 0;
                    state.isSwiping = false;
                    return;
                }
                state.touchStartX = event.touches[0].clientX;
                state.touchStartY = event.touches[0].clientY;
                state.isSwiping = false; // スワイプ開始時はフラグをリセット
                state.touchEndX = state.touchStartX; // touchendで使えるように初期化
                state.touchEndY = state.touchStartY;
            },

            handleTouchMove(event) {
                // 開始点がない、マルチタッチ、ズーム中は処理しない
                if (!state.touchStartX || event.touches.length > 1 || state.isZoomed) {
                    return;
                }

                const currentX = event.touches[0].clientX;
                const currentY = event.touches[0].clientY;
                const diffX = state.touchStartX - currentX;
                const diffY = state.touchStartY - currentY;

                // 横方向の移動が縦方向より大きい場合にスワイプと判定
                // isSwipingフラグを立てるのは閾値を超えたときではなく、横移動が優位な場合
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    state.isSwiping = true;
                    // 横スワイプ(画面遷移の可能性)中はデフォルトの縦スクロールを抑制
                    // これにより、意図しない縦スクロールと画面遷移の競合を防ぐ
                    event.preventDefault();
                } else {
                    // 縦方向の移動が大きい場合はスワイプフラグを解除
                    state.isSwiping = false;
                }
                // 現在位置を記録 (touchendで使うため)
                state.touchEndX = currentX;
                state.touchEndY = currentY;
            },

            handleTouchEnd(event) {
                 // ズーム状態を最終確認 (touchendまでに変わる可能性もあるため)
                 this.updateZoomState();
                 if (state.isZoomed) {
                     console.log("Zoomed state detected on touchend, skipping swipe navigation.");
                     this.resetSwipeState();
                     return;
                 }

                 // スワイプ中でない、または開始点がない場合はリセットして終了
                 if (!state.isSwiping || !state.touchStartX) {
                     this.resetSwipeState();
                     return;
                 }

                const diffX = state.touchStartX - state.touchEndX;
                const diffY = state.touchStartY - state.touchEndY; // 縦移動量も一応計算

                // スワイプ距離が閾値を超えているか、かつ横移動が縦移動より大きいか
                if (Math.abs(diffX) > SWIPE_THRESHOLD && Math.abs(diffX) > Math.abs(diffY)) {
                    if (diffX > 0) { // 左スワイプ (右から左へ) -> 設定画面へ
                        console.log("左スワイプ検出 -> 設定画面へ");
                        uiUtils.showScreen('settings'); // showScreenが履歴操作を行う
                    } else { // 右スワイプ (左から右へ) -> 履歴画面へ
                        console.log("右スワイプ検出 -> 履歴画面へ");
                        uiUtils.showScreen('history'); // showScreenが履歴操作を行う
                    }
                } else {
                    // 閾値未満または縦移動が大きい場合は何もしない
                    console.log("スワイプ距離不足 or 縦移動大");
                }

                this.resetSwipeState(); // スワイプ状態をリセット
            },

            resetSwipeState() {
                state.touchStartX = 0;
                state.touchStartY = 0;
                state.touchEndX = 0;
                state.touchEndY = 0;
                state.isSwiping = false;
            },
            // --- スワイプ処理ここまで ---


            // 新規チャット開始の確認と実行
            async confirmStartNewChat() {
                // 送信中なら中断確認
                if (state.isSending) {
                    const confirmed = await uiUtils.showCustomConfirm("送信中です。中断して新規チャットを開始しますか？");
                    if (!confirmed) return;
                    this.abortRequest(); // 送信中断
                }
                // 編集中なら破棄確認
                if (state.editingMessageIndex !== null) {
                    const confirmed = await uiUtils.showCustomConfirm("編集中です。変更を破棄して新規チャットを開始しますか？");
                    if (!confirmed) return;
                    const msgEl = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                    this.cancelEditMessage(state.editingMessageIndex, msgEl); // 編集キャンセル
                }
                // システムプロンプト編集中なら破棄確認
                if (state.isEditingSystemPrompt) {
                    const confirmed = await uiUtils.showCustomConfirm("システムプロンプト編集中です。変更を破棄して新規チャットを開始しますか？");
                    if (!confirmed) return;
                    this.cancelEditSystemPrompt();
                }
                // 現在のチャットにメッセージまたはシステムプロンプトがあり、IDもあれば保存を試みる
                if ((state.currentMessages.length > 0 || state.currentSystemPrompt) && state.currentChatId) {
                    try {
                        await dbUtils.saveChat();
                    } catch (error) {
                        console.error("新規チャット開始前のチャット保存失敗:", error);
                        const conf = await uiUtils.showCustomConfirm("現在のチャットの保存に失敗しました。新規チャットを開始しますか？");
                        if (!conf) return; // 保存失敗時にキャンセルされたら中断
                    }
                }
                // 新規チャットを開始
                this.startNewChat();
                uiUtils.showScreen('chat'); // チャット画面を表示 (URLハッシュも更新)
            },

            // 新規チャットを開始する (状態リセット)
            startNewChat() {
                state.currentChatId = null; // IDリセット
                state.currentMessages = []; // メッセージクリア
                state.currentSystemPrompt = state.settings.systemPrompt; // デフォルトのシステムプロンプトを適用
                uiUtils.updateSystemPromptUI(); // システムプロンプトUI更新
                uiUtils.renderChatMessages(); // 表示クリア
                uiUtils.updateChatTitle(); // タイトルを「新規チャット」に
                elements.userInput.value = ''; // 入力欄クリア
                uiUtils.adjustTextareaHeight(); // 高さ調整
                uiUtils.setSendingState(false); // 送信状態リセット
            },

            // 指定IDのチャットを読み込む
            async loadChat(id) {
                 // 送信中なら中断確認
                 if (state.isSending) {
                     const confirmed = await uiUtils.showCustomConfirm("送信中です。中断して別のチャットを読み込みますか？");
                     if (!confirmed) return;
                     this.abortRequest();
                 }
                 // 編集中なら破棄確認
                 if (state.editingMessageIndex !== null) {
                     const confirmed = await uiUtils.showCustomConfirm("編集中です。変更を破棄して別のチャットを読み込みますか？");
                     if (!confirmed) return;
                     const msgEl = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`);
                     this.cancelEditMessage(state.editingMessageIndex, msgEl);
                 }
                 // システムプロンプト編集中なら破棄確認
                 if (state.isEditingSystemPrompt) {
                     const confirmed = await uiUtils.showCustomConfirm("システムプロンプト編集中です。変更を破棄して別のチャットを読み込みますか？");
                     if (!confirmed) return;
                     this.cancelEditSystemPrompt();
                 }

                try {
                    const chat = await dbUtils.getChat(id); // DBからチャット取得
                    if (chat) {
                        state.currentChatId = chat.id;
                        state.currentMessages = chat.messages || []; // メッセージをstateに設定

                        // --- カスケード応答の isSelected を正規化 ---
                        let needsSave = false;
                        const groupIds = new Set(state.currentMessages.filter(m => m.siblingGroupId).map(m => m.siblingGroupId));
                        groupIds.forEach(gid => {
                            const siblings = state.currentMessages.filter(m => m.siblingGroupId === gid);
                            const selected = siblings.filter(m => m.isSelected);
                            if (selected.length === 0 && siblings.length > 0) {
                                // 選択されているものがない -> 最後のものを選択状態にする
                                siblings[siblings.length - 1].isSelected = true;
                                needsSave = true;
                            } else if (selected.length > 1) {
                                // 複数選択されている -> 最後のもの以外を解除
                                selected.slice(0, -1).forEach(m => m.isSelected = false);
                                needsSave = true;
                            }
                        });
                        // -----------------------------------------

                        // システムプロンプトを読み込み (存在しなければデフォルトを使用)
                        state.currentSystemPrompt = chat.systemPrompt !== undefined ? chat.systemPrompt : state.settings.systemPrompt;
                        uiUtils.updateSystemPromptUI(); // システムプロンプトUI更新
                        uiUtils.renderChatMessages(); // メッセージ表示更新 (正規化された isSelected を反映)
                        uiUtils.updateChatTitle(chat.title); // タイトル更新
                        elements.userInput.value = ''; // 入力欄クリア
                        uiUtils.adjustTextareaHeight();
                        uiUtils.setSendingState(false);

                        // isSelected の正規化で変更があった場合、DBに保存
                        if (needsSave) {
                            console.log("読み込み時に isSelected を正規化しました。DBに保存します。");
                            await dbUtils.saveChat();
                        }

                        // 読み込み成功後、履歴状態をチャット画面に設定 (戻るでアプリ終了を期待)
                        // 既にチャット画面が表示されているはずなので replaceState でよい
                        history.replaceState({ screen: 'chat' }, '', '#chat');
                        state.currentScreen = 'chat';
                        console.log("チャット読み込み完了:", id, "履歴状態を #chat に設定");
                    } else {
                        // チャットが見つからない場合
                        await uiUtils.showCustomAlert("チャット履歴が見つかりませんでした。");
                        this.startNewChat(); // 新規チャットを開始
                        uiUtils.showScreen('chat'); // チャット画面へ遷移させる
                    }
                } catch (error) {
                    await uiUtils.showCustomAlert(`チャットの読み込みエラー: ${error}`);
                    this.startNewChat(); // エラー時も新規チャットへ
                    uiUtils.showScreen('chat'); // チャット画面へ遷移させる
                }
            },

            // チャットを複製
            async duplicateChat(id) {
                // 送信中・編集中・他チャット保存の確認 (loadChatと同様)
                if (state.isSending) { const conf = await uiUtils.showCustomConfirm("送信中です。中断してチャットを複製しますか？"); if (!conf) return; this.abortRequest(); }
                if (state.editingMessageIndex !== null) { const conf = await uiUtils.showCustomConfirm("編集中です。変更を破棄してチャットを複製しますか？"); if (!conf) return; const msgEl = elements.messageContainer.querySelector(`.message[data-index="${state.editingMessageIndex}"]`); this.cancelEditMessage(state.editingMessageIndex, msgEl); }
                if (state.isEditingSystemPrompt) { const conf = await uiUtils.showCustomConfirm("システムプロンプト編集中です。変更を破棄してチャットを複製しますか？"); if (!conf) return; this.cancelEditSystemPrompt(); }
                if ((state.currentMessages.length > 0 || state.currentSystemPrompt) && state.currentChatId && state.currentChatId !== id) { try { await dbUtils.saveChat(); } catch (error) { console.error("複製前の現チャット保存失敗:", error); const conf = await uiUtils.showCustomConfirm("現在のチャット保存に失敗しました。複製を続行しますか？"); if (!conf) return; } }

                try {
                    const chat = await dbUtils.getChat(id); // 複製元を取得
                    if (chat) {
                        // 新しいタイトルを作成 (末尾のコピーサフィックスを除去して再度付与)
                        const originalTitle = chat.title || "無題のチャット";
                        const newTitle = originalTitle.replace(new RegExp(DUPLICATE_SUFFIX.replace(/([().])/g, '\\$1') + '$'), '').trim() + DUPLICATE_SUFFIX;

                        // メッセージをディープコピーし、新しい siblingGroupId を生成
                        const duplicatedMessages = [];
                        const groupIdMap = new Map(); // 古いGroupId -> 新しいGroupId
                        (chat.messages || []).forEach(msg => {
                            const newMsg = JSON.parse(JSON.stringify(msg)); // ディープコピー
                            // 新しいフラグもコピー (isSelected は後で調整)
                            newMsg.isCascaded = msg.isCascaded ?? false;
                            newMsg.isSelected = msg.isSelected ?? false;
                            if (msg.siblingGroupId) {
                                if (!groupIdMap.has(msg.siblingGroupId)) {
                                    groupIdMap.set(msg.siblingGroupId, `dup-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`);
                                }
                                newMsg.siblingGroupId = groupIdMap.get(msg.siblingGroupId);
                            } else {
                                delete newMsg.siblingGroupId; // 元々なければ削除
                            }
                            duplicatedMessages.push(newMsg);
                        });

                        // 複製後の isSelected を正規化 (各グループの最後のものを選択)
                        const newGroupIds = new Set(duplicatedMessages.filter(m => m.siblingGroupId).map(m => m.siblingGroupId));
                        newGroupIds.forEach(gid => {
                            const siblings = duplicatedMessages.filter(m => m.siblingGroupId === gid);
                            siblings.forEach((m, idx) => {
                                m.isSelected = (idx === siblings.length - 1); // 最後のものだけ true
                            });
                        });

                        // 新しいチャットデータを作成
                        const newChatData = {
                            messages: duplicatedMessages,
                            systemPrompt: chat.systemPrompt || '', // システムプロンプトもコピー
                            updatedAt: Date.now(), // 更新/作成日時は現在
                            createdAt: Date.now(),
                            title: newTitle
                        };
                        // 新しいチャットとしてDBに追加
                        const newChatId = await new Promise((resolve, reject) => {
                            const store = dbUtils._getStore(CHATS_STORE, 'readwrite');
                            const request = store.add(newChatData); // addで新規追加
                            request.onsuccess = (event) => resolve(event.target.result); // 新しいIDを返す
                            request.onerror = (event) => reject(event.target.error);
                        });
                        console.log("チャット複製完了:", id, "->", newChatId);
                        // 履歴画面が表示されていればリストを更新、そうでなければアラート表示
                        if (state.currentScreen === 'history') { // stateで判定
                            uiUtils.renderHistoryList();
                        } else {
                            await uiUtils.showCustomAlert(`チャット「${newTitle}」を複製しました。`);
                        }
                    } else {
                        await uiUtils.showCustomAlert("複製元のチャットが見つかりません。");
                    }
                } catch (error) {
                    await uiUtils.showCustomAlert(`チャット複製エラー: ${error}`);
                }
            },

            // チャットをテキストファイルとしてエクスポート
            async exportChat(chatId, chatTitle) {
                 const confirmed = await uiUtils.showCustomConfirm(`チャット「${chatTitle || 'この履歴'}」をテキスト出力しますか？`);
                 if (!confirmed) return;

                 try {
                     const chat = await dbUtils.getChat(chatId);
                     if (!chat || ((!chat.messages || chat.messages.length === 0) && !chat.systemPrompt)) {
                         await uiUtils.showCustomAlert("チャットデータが空です。");
                         return;
                     }
                     // エクスポート用テキスト生成
                     let exportText = '';
                     // システムプロンプトを出力
                     if (chat.systemPrompt) {
                         exportText += `<|#|system|#|>\n${chat.systemPrompt}\n<|#|/system|#|>\n\n`;
                     }
                     // メッセージを出力
                     if (chat.messages) {
                         chat.messages.forEach(msg => {
                             // userとmodelのメッセージのみ出力
                             if (msg.role === 'user' || msg.role === 'model') {
                                 let attributes = '';
                                 if (msg.role === 'model') {
                                     if (msg.isCascaded) attributes += ' isCascaded';
                                     if (msg.isSelected) attributes += ' isSelected';
                                     // siblingGroupId はエクスポートしない方針
                                 }
                                 exportText += `<|#|${msg.role}|#|${attributes}>\n${msg.content}\n<|#|/${msg.role}|#|>\n\n`;
                             }
                         });
                     }
                     // Blobを作成してダウンロードリンクを生成
                     const blob = new Blob([exportText.trim()], { type: 'text/plain;charset=utf-8' });
                     const url = URL.createObjectURL(blob);
                     const a = document.createElement('a');
                     // ファイル名を生成 (不正文字を置換)
                     const safeTitle = (chatTitle || `chat_${chatId}_export`).replace(/[<>:"/\\|?*\s]/g, '_');
                     a.href = url;
                     a.download = `${safeTitle}.txt`;
                     document.body.appendChild(a); // bodyに追加してクリック可能に
                     a.click(); // ダウンロード実行
                     document.body.removeChild(a); // 要素削除
                     URL.revokeObjectURL(url); // URL破棄
                     console.log("チャットエクスポート完了:", chatId);
                 } catch (error) {
                     await uiUtils.showCustomAlert(`エクスポートエラー: ${error}`);
                 }
            },

            // チャット削除の確認と実行 (メッセージペア全体)
            async confirmDeleteChat(id, title) {
                 const confirmed = await uiUtils.showCustomConfirm(`「${title || 'この履歴'}」を削除しますか？`);
                 if (confirmed) {
                    const isDeletingCurrent = state.currentChatId === id;
                    const currentScreenBeforeDelete = state.currentScreen;

                    try {
                        // 1. DBから削除
                        await dbUtils.deleteChat(id);
                        console.log("チャット削除:", id);

                        // 2. 表示中チャット削除なら内部状態リセット
                        if (isDeletingCurrent) {
                            console.log("表示中のチャットが削除されたため、内部状態を新規チャットにリセット。");
                            this.startNewChat(); // 状態リセットのみ
                        }

                        // 3. 履歴画面での操作ならリストUI更新 & 状態リセット判定
                        if (currentScreenBeforeDelete === 'history') {
                            console.log("履歴画面での操作のため、リストUIを更新します。");
                            await uiUtils.renderHistoryList(); // リストUIを更新
                            const listIsEmpty = elements.historyList.querySelectorAll('.history-item:not(.js-history-item-template)').length === 0;

                            // リストが空になった場合、内部状態をリセットする（念のため）
                            if (listIsEmpty) {
                                console.log("履歴リストが空になりました。");
                                if (!isDeletingCurrent) {
                                    this.startNewChat();
                                }
                            }
                        }

                    } catch (error) {
                        await uiUtils.showCustomAlert(`チャット削除エラー: ${error}`);
                        uiUtils.setSendingState(false); // エラー時も送信状態解除
                    }
                }
            },

            // 履歴アイテムのタイトルを編集
            async editHistoryTitle(chatId, titleElement) {
                const currentTitle = titleElement.textContent;
                const newTitle = await uiUtils.showCustomPrompt("新しいタイトル:", currentTitle); // newTitle は OK なら文字列、キャンセルなら ''

                // キャンセル時('')でなく、入力があり(trim後空でなく)、変更があった場合
                const trimmedTitle = (newTitle !== null) ? newTitle.trim() : '';

                if (newTitle !== '' && trimmedTitle !== '' && trimmedTitle !== currentTitle) {
                    const finalTitle = trimmedTitle.substring(0, 100); // 100文字に制限
                    try {
                        await dbUtils.updateChatTitleDb(chatId, finalTitle); // DB更新
                        // UI更新
                        titleElement.textContent = finalTitle;
                        titleElement.title = finalTitle; // ホバータイトルも更新
                        // 更新日時も更新表示
                        const dateElement = titleElement.closest('.history-item')?.querySelector('.updated-date');
                        if(dateElement) dateElement.textContent = `更新: ${uiUtils.formatDate(Date.now())}`;
                        // 現在表示中のチャットのタイトルが変更されたら、ヘッダーも更新
                        if (state.currentChatId === chatId) {
                            uiUtils.updateChatTitle(finalTitle);
                        }
                    } catch (error) {
                        await uiUtils.showCustomAlert(`タイトル更新エラー: ${error}`);
                    }
                } else {
                    // キャンセルまたは変更なし
                    console.log("タイトル編集キャンセルまたは変更なし");
                }
            },

            // テキストを1文字ずつタイプ表示 (ストリーミング風)
            async typeCharacterByCharacter(textChunks, messageIndex, signal, prefix = '') {
                const speed = state.settings.streamingSpeed;
                let accumulatedRawContent = prefix; // 初期値をprefixに
                state.partialStreamContent = prefix; // 初期値をprefixに

                // プレフィックスがあれば最初に表示
                if (prefix) {
                    uiUtils.updateStreamingMessage(messageIndex, ''); // プレフィックスを反映させるための初期更新
                }

                // 速度設定が無効なら一括表示 (プレフィックス含む)
                if (!speed || speed <= 0) {
                    accumulatedRawContent = prefix + textChunks.join(''); // prefixを連結
                    state.partialStreamContent = accumulatedRawContent;
                    uiUtils.updateStreamingMessage(messageIndex, ''); // 一括でUI更新
                    return accumulatedRawContent;
                }

                console.log(`タイピングエフェクト速度: ${speed}ms`);
                // チャンクと文字をループ
                for (const chunk of textChunks) {
                    if(typeof chunk !== 'string') continue; // 文字列でないチャンクはスキップ
                    for (const char of chunk) {
                        // 中断シグナルをチェック
                        if (signal.aborted) {
                            console.log("タイピング中断");
                            return accumulatedRawContent; // 中断時点のテキストを返す
                        }
                        accumulatedRawContent += char; // 生テキストに追加
                        state.partialStreamContent = accumulatedRawContent; // 部分表示用コンテンツ更新
                        uiUtils.updateStreamingMessage(messageIndex, char); // UI更新
                        await sleep(speed); // 指定時間待機
                    }
                }
                console.log("タイピングエフェクト完了");
                return accumulatedRawContent; // 全てのテキストを返す
            },

            // 送信処理 (リトライ時も使用)
            async handleSend(isRetry = false, retryMessagesForApi = null) { // 引数名変更
                // 編集中は送信不可
                if (state.editingMessageIndex !== null) {
                    await uiUtils.showCustomAlert("他のメッセージを編集中です。");
                    return;
                }
                // システムプロンプト編集中は送信不可
                if (state.isEditingSystemPrompt) {
                    await uiUtils.showCustomAlert("システムプロンプトを編集中です。");
                    return;
                }
                // 送信するテキストを取得 (リトライ時は最後のメッセージ、通常は入力欄)
                const text = isRetry ? retryMessagesForApi[retryMessagesForApi.length - 1].content : elements.userInput.value.trim();

                // 送信中、またはテキストが空の場合は何もしない (リトライ時は空でもOK)
                if (state.isSending || (!text && !isRetry)) {
                    if(!text && !isRetry) console.log("入力が空です。");
                    return;
                }
                // APIキーチェック
                if (!state.settings.apiKey) {
                    await uiUtils.showCustomAlert("APIキーが設定されていません。設定画面を開きます。");
                    uiUtils.showScreen('settings');
                    return;
                }

                uiUtils.setSendingState(true); // 送信状態開始
                state.partialStreamContent = ''; // 部分コンテンツリセット

                let userMessageIndex = -1; // リトライ時に使うユーザーメッセージのインデックス
                let existingSiblingGroupId = null; // catchブロックからも参照するためここで宣言
                let firstResponseIndexForRetry = -1; // リトライ時に最初の応答のインデックスを保持
                let siblingGroupIdToUse = null; // try/catch 両方から参照できるようここで宣言＆初期化

                // 通常送信の場合、ユーザーメッセージをリストとUIに追加
                if (!isRetry) {
                    const userMessage = { role: 'user', content: text, timestamp: Date.now() };
                    state.currentMessages.push(userMessage);
                    userMessageIndex = state.currentMessages.length - 1;
                    uiUtils.appendMessage(userMessage.role, userMessage.content, userMessageIndex);
                    elements.userInput.value = ''; // 入力欄クリア
                    uiUtils.adjustTextareaHeight();
                    uiUtils.scrollToBottom();
                } else {
                    // リトライの場合
                    // API送信用履歴の最後のメッセージがリトライ対象のユーザーメッセージ
                    // state.currentMessages 内でのインデックスを探す
                    userMessageIndex = state.currentMessages.findIndex(msg => msg === retryMessagesForApi[retryMessagesForApi.length - 1]);
                    if (userMessageIndex === -1) {
                        console.error("リトライ対象のユーザーメッセージが state.currentMessages に見つかりません。");
                        uiUtils.setSendingState(false);
                        return; // エラー処理
                    }
                    console.log("リトライ開始:", state.currentMessages[userMessageIndex]);

                    // siblingGroupIdの決定を try ブロックに入る前に行う
                    let siblingStartIndex = userMessageIndex + 1;
                    while (siblingStartIndex < state.currentMessages.length && state.currentMessages[siblingStartIndex].role !== 'model') {
                        siblingStartIndex++; // ユーザーの次にモデル以外があればスキップ
                    }

                    if (siblingStartIndex < state.currentMessages.length && state.currentMessages[siblingStartIndex].role === 'model') {
                         // 最初の応答が見つかった
                         firstResponseIndexForRetry = siblingStartIndex;
                         const firstResponse = state.currentMessages[firstResponseIndexForRetry];
                         if (firstResponse.isCascaded && firstResponse.siblingGroupId) {
                             // 既存のグループが見つかった
                             existingSiblingGroupId = firstResponse.siblingGroupId; // 既存IDを取得
                             // 同じ siblingGroupId を持つすべてのメッセージの isSelected を false に設定
                             state.currentMessages.forEach(msg => {
                                 if (msg.siblingGroupId === existingSiblingGroupId) {
                                     msg.isSelected = false;
                                 }
                             });
                             console.log(`リトライ: 既存の応答グループ (${existingSiblingGroupId}) の isSelected を false に設定.`);
                             siblingGroupIdToUse = existingSiblingGroupId; // 確定したIDを代入
                         } else {
                             // 最初の応答だが、まだグループ化されていない場合
                             console.log("リトライ: 最初の応答を新しいカスケードグループに含めます。");
                             // siblingGroupIdToUse は null のまま -> try または catch ブロック内で生成される
                         }
                    } else {
                        // ユーザーメッセージの後にモデル応答がない場合
                        console.warn("リトライ対象のユーザーメッセージの後にモデル応答が見つかりません。");
                        // siblingGroupIdToUse は null のまま
                    }
                }

                // APIに送信するメッセージリストを準備
                // リトライ時は渡されたもの、通常は現在の全メッセージから生成
                const messagesToProcess = isRetry ? [...retryMessagesForApi] : [...state.currentMessages];

                // 送信する前に現在のチャット状態を保存 (タイトルも推測して保存)
                try {
                    let titleToSave = null;
                    // 既存チャットならタイトルを取得
                    if(state.currentChatId) {
                        const currentChat = await dbUtils.getChat(state.currentChatId);
                        if(currentChat) titleToSave = currentChat.title;
                    }
                    // タイトルがなければ最初のユーザーメッセージから推測
                    if (!titleToSave) {
                        const firstUserMsg = state.currentMessages.find(m => m.role === 'user');
                        if(firstUserMsg) {
                            titleToSave = firstUserMsg.content.substring(0, 50);
                        }
                    }
                    await dbUtils.saveChat(titleToSave); // タイトルを指定して保存 (systemPrompt, isSelectedなども保存される)
                } catch (error) {
                    console.error("送信前のチャット保存失敗:", error);
                    uiUtils.displayError("チャットの保存に失敗しましたが、送信を試みます。", false);
                }

                // APIリクエスト用の形式に変換 (userは常に、modelは条件付き)
                const apiMessages = messagesToProcess
                    .filter(msg => {
                        if (msg.role === 'user') {
                            return true; // ユーザーメッセージは常に含める
                        }
                        if (msg.role === 'model') {
                            // モデルメッセージの場合:
                            // isCascaded でない (通常の応答) か、
                            // isCascaded であり、かつ isSelected である (選択中のカスケード応答) 場合に true を返す
                            return !msg.isCascaded || (msg.isCascaded && msg.isSelected);
                        }
                        return false; // その他のロールは含めない (エラーメッセージなど)
                    })
                    .map(msg => ({ role: msg.role, parts: [{ text: msg.content }] })); // API形式に変換

                // ダミープロンプトを追加 (設定されていれば)
                const dummyUserText = state.settings.dummyUser?.trim();
                const dummyModelText = state.settings.dummyModel?.trim();
                if (dummyUserText) apiMessages.push({ role: 'user', parts: [{ text: dummyUserText }] });
                if (dummyModelText) apiMessages.push({ role: 'model', parts: [{ text: dummyModelText }] });

                // 生成設定 (generationConfig) を作成
                const generationConfig = {};
                if (state.settings.temperature !== null) generationConfig.temperature = state.settings.temperature;
                if (state.settings.maxTokens !== null) generationConfig.maxOutputTokens = state.settings.maxTokens;
                if (state.settings.topK !== null) generationConfig.topK = state.settings.topK;
                if (state.settings.topP !== null) generationConfig.topP = state.settings.topP;

                // システムプロンプト (systemInstruction) を作成 (現在のチャットのものを使用)
                const systemInstruction = state.currentSystemPrompt?.trim()
                    ? { role: "system", parts: [{ text: state.currentSystemPrompt.trim() }] }
                    : null;

                let modelResponseRawContent = ''; // モデル応答の生テキスト
                let modelResponseMetadata = {}; // 応答メタデータ (finishReasonなど)
                const modelMessageIndex = state.currentMessages.length; // 新しいモデル応答メッセージのインデックス

                try {
                    // API呼び出し
                    const response = await apiUtils.callGeminiApi(apiMessages, generationConfig, systemInstruction);

                    // プレフィックスを決定 (ダミーモデル連結用)
                    const dummyModelPrefix = (state.settings.concatDummyModel && state.settings.dummyModel) ? state.settings.dummyModel : '';

                    // ストリーミング処理
                    if (state.settings.streamingOutput) {
                        // プレースホルダーを追加 (一時的なもの)
                        const tempPlaceholderIndex = state.currentMessages.length; // 実際の追加前にインデックス確保
                        uiUtils.appendMessage('model', '', tempPlaceholderIndex, true);
                        // ストリームを処理
                        const streamResult = await apiUtils.handleStreamingResponse(response);
                        modelResponseMetadata = { finishReason: streamResult.finishReason, safetyRatings: streamResult.safetyRatings };
                        // テキストチャンクをタイプ表示 (プレフィックスを渡す)
                        modelResponseRawContent = await this.typeCharacterByCharacter(streamResult.textChunks, tempPlaceholderIndex, state.abortController.signal, dummyModelPrefix);
                        // 中断された場合はエラーを投げる
                        if (modelResponseMetadata.finishReason === 'ABORTED' || state.abortController?.signal.aborted) {
                            throw new Error("リクエストがキャンセルされました。");
                        }
                        // 完了後、一時プレースホルダーを削除 (renderChatMessagesで再描画するため)
                        const placeholderElement = document.getElementById(`streaming-message-${tempPlaceholderIndex}`);
                        if (placeholderElement) placeholderElement.remove();

                    } else { // 非ストリーミング処理
                        const data = await response.json();
                        console.log("API応答 (非ストリーミング):", data);
                        const candidate = data.candidates?.[0];
                        let rawContentFromApi = ""; // APIからの生コンテンツ
                        if (candidate) {
                            modelResponseMetadata = { finishReason: candidate.finishReason, safetyRatings: candidate.safetyRatings };
                            rawContentFromApi = candidate.content?.parts?.[0]?.text || "";
                            if (candidate.finishReason && candidate.finishReason !== "STOP" && candidate.finishReason !== "MAX_TOKENS") {
                                rawContentFromApi += `\n\n(理由: ${candidate.finishReason})`;
                            }
                            if (!rawContentFromApi && candidate.finishReason === "STOP") {
                                rawContentFromApi = "(応答が空です)";
                            }
                        } else {
                            rawContentFromApi = "応答候補がありません";
                            if(data.promptFeedback) {
                                rawContentFromApi += ` (理由: ${data.promptFeedback.blockReason || '不明'})`;
                                modelResponseMetadata.promptFeedback = data.promptFeedback;
                                modelResponseMetadata.finishReason = data.promptFeedback.blockReason || 'ERROR';
                            } else {
                                modelResponseMetadata.finishReason = 'ERROR';
                            }
                        }
                        modelResponseRawContent = dummyModelPrefix + rawContentFromApi;
                    }

                    // モデル応答があればメッセージリストに追加して保存
                    if (modelResponseRawContent || modelResponseMetadata.finishReason) {
                         const newModelMessage = {
                             role: 'model',
                             content: modelResponseRawContent,
                             timestamp: Date.now(),
                             ...modelResponseMetadata
                         };

                         // --- カスケード関連フラグの設定 ---
                         // リトライ時、または最初の応答の場合に設定
                         let targetUserIndexForCascade = -1;
                         if (isRetry) {
                             targetUserIndexForCascade = userMessageIndex;
                         } else {
                             // 通常送信の場合、最後のユーザーメッセージを探す
                             for(let i = state.currentMessages.length - 1; i >= 0; i--) {
                                 if (state.currentMessages[i].role === 'user') {
                                     targetUserIndexForCascade = i;
                                     break;
                                 }
                             }
                         }

                         if (targetUserIndexForCascade !== -1) {
                             // siblingGroupId を決定 (リトライ開始時に決定できなかった場合のみ新規生成)
                             if (siblingGroupIdToUse === null) {
                                 siblingGroupIdToUse = `gid-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
                                 console.log("カスケードフラグ設定: 新規 siblingGroupId を生成:", siblingGroupIdToUse);
                             }

                             newModelMessage.isCascaded = true;
                             newModelMessage.isSelected = true; // 新しい応答を選択状態に
                             newModelMessage.siblingGroupId = siblingGroupIdToUse; // 確定した or 新規生成したIDを使用

                             // 最初の応答にもフラグとIDを設定 (まだ設定されていなければ)
                             if (isRetry && firstResponseIndexForRetry !== -1 && state.currentMessages[firstResponseIndexForRetry] && !state.currentMessages[firstResponseIndexForRetry].isCascaded) {
                                 state.currentMessages[firstResponseIndexForRetry].isCascaded = true;
                                 state.currentMessages[firstResponseIndexForRetry].siblingGroupId = siblingGroupIdToUse; // 同じIDを使用
                                 // 最初の応答は isSelected = false のまま
                                 console.log(`最初の応答 (index ${firstResponseIndexForRetry}) にフラグ設定: isCascaded=true, siblingGroupId=${siblingGroupIdToUse}`);
                             }

                             console.log(`応答にフラグ設定: isCascaded=true, isSelected=true, siblingGroupId=${newModelMessage.siblingGroupId}`);
                         }
                         // ---------------------------------

                         state.currentMessages.push(newModelMessage);

                         // UIを再描画して新しいメッセージとカスケードコントロールを表示
                         uiUtils.renderChatMessages();

                         await dbUtils.saveChat(); // チャットを保存
                         console.log("モデル応答保存完了");
                    } else {
                        // 応答コンテンツがない場合は保存しない
                        console.log("モデル応答コンテンツがないため保存しません。");
                    }
                } catch (error) { // API呼び出し、ストリーミング、中断エラーのハンドリング
                    console.error("Gemini呼び出し/処理中のエラー:", error);
                    const isAbort = error.message === "リクエストがキャンセルされました。";
                    const displayErrorMessage = isAbort ? error.message : (error.message || "不明なエラーが発生しました");

                    // ストリーミングエラー時の部分コンテンツにもプレフィックスを考慮
                    const partialRawContent = state.partialStreamContent || error.cause?.partialChunks?.join('');

                    if (partialRawContent && state.settings.streamingOutput) {
                         // 部分的なコンテンツにエラー/中断情報を追記して保存
                         const finalPartialContent = partialRawContent + `\n\n(${isAbort ? '中断されました' : 'エラーが発生しました'})`;
                         const partialMessage = {
                             role: 'model',
                             content: finalPartialContent,
                             timestamp: Date.now(),
                             error: true, // エラーフラグ
                             finishReason: isAbort ? 'ABORTED' : (modelResponseMetadata.finishReason || 'ERROR'),
                             ...(modelResponseMetadata.safetyRatings && { safetyRatings: modelResponseMetadata.safetyRatings })
                         };

                         // リトライ中の中断エラーの場合、カスケードフラグを設定
                         if (isRetry && isAbort) {
                             // siblingGroupIdToUse が null の場合のみ新規生成（リトライ開始時に既存IDがなかった場合）
                             if (siblingGroupIdToUse === null) {
                                 siblingGroupIdToUse = `gid-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
                                 // このログは通常表示されなくなるはず
                                 console.log("リトライ中断エラー: 新規 siblingGroupId を生成:", siblingGroupIdToUse);
                             } else {
                                 console.log("リトライ中断エラー: 既存の siblingGroupId を使用:", siblingGroupIdToUse); // 確認用ログ
                             }
                             partialMessage.isCascaded = true;
                             partialMessage.siblingGroupId = siblingGroupIdToUse; // リトライ開始時に決定したIDを使用
                             partialMessage.isSelected = true; // 中断されたものを選択状態にする
                             console.log(`リトライ中断エラー: 部分メッセージにカスケードフラグ設定 (gid: ${siblingGroupIdToUse})`);

                             // 最初の応答のカスケード化 (tryブロック内のロジックと同様)
                             // state.currentMessages は partialMessage を push する前なので、元のインデックスでアクセス可能
                             if (firstResponseIndexForRetry !== -1 && state.currentMessages[firstResponseIndexForRetry] && !state.currentMessages[firstResponseIndexForRetry].isCascaded) {
                                 state.currentMessages[firstResponseIndexForRetry].isCascaded = true;
                                 state.currentMessages[firstResponseIndexForRetry].siblingGroupId = siblingGroupIdToUse; // 同じIDを使用
                                 console.log(`リトライ中断エラー: 最初の応答 (index ${firstResponseIndexForRetry}) にもフラグ設定: isCascaded=true, siblingGroupId=${siblingGroupIdToUse}`);
                             }
                         }

                         state.currentMessages.push(partialMessage);
                         try {
                             await dbUtils.saveChat(); // 部分的な状態を保存
                             console.log("部分的なメッセージ状態を保存しました。");
                             // UIを再描画してエラーメッセージを表示
                             uiUtils.renderChatMessages();
                         } catch (saveError) {
                             console.error("部分メッセージの保存失敗:", saveError);
                             uiUtils.displayError(displayErrorMessage, !isAbort);
                         }
                    } else {
                        // 部分コンテンツがない、または非ストリーミング時のエラー
                        uiUtils.displayError(displayErrorMessage, !isAbort);
                    }
                } finally {
                    // 最終処理
                    uiUtils.setSendingState(false); // 送信状態解除
                    state.abortController = null; // AbortControllerリセット
                    state.partialStreamContent = ''; // 部分コンテンツリセット
                    uiUtils.scrollToBottom(); // 最下部へスクロール
                }
            },

            // APIリクエストを中断
            abortRequest() {
                if (state.abortController) {
                    console.log("中断リクエスト送信");
                    state.abortController.abort(); // AbortControllerで中断
                } else {
                    console.log("中断するアクティブなリクエストがありません。");
                }
            },

            // --- 履歴インポートハンドラ ---
            async handleHistoryImport(file) {
                if (!file || !file.type.startsWith('text/plain')) {
                    await uiUtils.showCustomAlert("テキストファイル (.txt) を選択してください。");
                    return;
                }
                console.log("履歴インポート開始:", file.name);
                const reader = new FileReader();

                reader.onload = async (event) => {
                    const textContent = event.target.result;
                    if (!textContent) {
                        await uiUtils.showCustomAlert("ファイルの内容が空です。");
                        return;
                    }
                    try {
                        const { messages: importedMessages, systemPrompt: importedSystemPrompt } = this.parseImportedHistory(textContent);
                        if (importedMessages.length === 0 && !importedSystemPrompt) {
                            await uiUtils.showCustomAlert("ファイルから有効なメッセージまたはシステムプロンプトを読み込めませんでした。形式を確認してください。");
                            return;
                        }

                        // --- インポート後の siblingGroupId 割り当て ---
                        let currentGroupId = null;
                        let lastUserIndex = -1;
                        for (let i = 0; i < importedMessages.length; i++) {
                            const msg = importedMessages[i];
                            if (msg.role === 'user') {
                                lastUserIndex = i;
                                currentGroupId = null; // ユーザーメッセージでグループリセット
                            } else if (msg.role === 'model' && msg.isCascaded) {
                                if (currentGroupId === null && lastUserIndex !== -1) {
                                    // 新しいグループIDを生成
                                    currentGroupId = `imp-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
                                }
                                if (currentGroupId) {
                                    msg.siblingGroupId = currentGroupId;
                                }
                            } else {
                                currentGroupId = null; // 非カスケードモデルでグループリセット
                            }
                        }
                        // --- isSelected の正規化 (各グループの最後のものを選択) ---
                        const groupIds = new Set(importedMessages.filter(m => m.siblingGroupId).map(m => m.siblingGroupId));
                        groupIds.forEach(gid => {
                            const siblings = importedMessages.filter(m => m.siblingGroupId === gid);
                            const selected = siblings.filter(m => m.isSelected);
                            if (selected.length === 0 && siblings.length > 0) {
                                siblings[siblings.length - 1].isSelected = true;
                            } else if (selected.length > 1) {
                                selected.slice(0, -1).forEach(m => m.isSelected = false);
                                // 最後の isSelected は true のまま
                            }
                        });
                        // -----------------------------------------

                        // ファイル名から拡張子を除去してタイトル生成
                        const fileNameWithoutExt = file.name.replace(/\.[^/.]+$/, "");
                        const newTitle = IMPORT_PREFIX + (fileNameWithoutExt || `Imported_${Date.now()}`);

                        const newChatData = {
                            messages: importedMessages,
                            systemPrompt: importedSystemPrompt || '', // インポートされたシステムプロンプト
                            updatedAt: Date.now(),
                            createdAt: Date.now(),
                            title: newTitle.substring(0, 100) // 100文字制限
                        };

                        // 新しいチャットとしてDBに追加
                        const newChatId = await new Promise((resolve, reject) => {
                            const store = dbUtils._getStore(CHATS_STORE, 'readwrite');
                            const request = store.add(newChatData);
                            request.onsuccess = (event) => resolve(event.target.result);
                            request.onerror = (event) => reject(event.target.error);
                        });

                        console.log("履歴インポート成功:", newChatId);
                        await uiUtils.showCustomAlert(`履歴「${newChatData.title}」をインポートしました。`);
                        // 履歴リストを再描画
                        uiUtils.renderHistoryList();

                    } catch (error) {
                        console.error("履歴インポート処理エラー:", error);
                        await uiUtils.showCustomAlert(`履歴のインポート中にエラーが発生しました: ${error.message}`);
                    }
                };

                reader.onerror = async (event) => {
                    console.error("ファイル読み込みエラー:", event.target.error);
                    await uiUtils.showCustomAlert("ファイルの読み込みに失敗しました。");
                };

                reader.readAsText(file); // ファイルをテキストとして読み込む
            },

            // インポートされたテキストをパースする
            parseImportedHistory(text) {
                const messages = [];
                let systemPrompt = '';
                // 正規表現を修正: <|#|role|#| [attributes]>\ncontent\n<|#|/role|#|>
                const blockRegex = /<\|#\|(system|user|model)\|#\|([^>]*)>([\s\S]*?)<\|#\|\/\1\|#\|>/g;
                let match;

                while ((match = blockRegex.exec(text)) !== null) {
                    const role = match[1];
                    const attributesString = match[2].trim(); // 属性文字列 (例: "isCascaded isSelected")
                    const content = match[3].trim(); // コンテンツ

                    if (role === 'system' && content) {
                        systemPrompt = content; // システムプロンプトを抽出
                    } else if ((role === 'user' || role === 'model') && content) {
                        const messageData = {
                            role: role,
                            content: content,
                            timestamp: Date.now() // インポート時のタイムスタンプ
                        };
                        // 属性をパースしてフラグを設定
                        if (role === 'model') {
                            messageData.isCascaded = attributesString.includes('isCascaded');
                            messageData.isSelected = attributesString.includes('isSelected');
                            // siblingGroupId はインポート後に割り当てる
                        }
                        messages.push(messageData);
                    }
                }
                console.log(`インポートテキストから ${messages.length} 件のメッセージとシステムプロンプト(${systemPrompt ? 'あり' : 'なし'})をパースしました。`);
                return { messages, systemPrompt };
            },
            // -------------------------------

            // --- 背景画像ハンドラ ---
             // 背景画像アップロード処理
             async handleBackgroundImageUpload(file) {
                 console.log("選択されたファイル:", file.name, file.type, file.size);
                 const maxSize = 5 * 1024 * 1024; // 5MB制限 (例)
                 if (file.size > maxSize) {
                     await uiUtils.showCustomAlert(`画像サイズが大きすぎます (${(maxSize / 1024 / 1024).toFixed(1)}MB以下にしてください)`);
                     return;
                 }
                 if (!file.type.startsWith('image/')) {
                     await uiUtils.showCustomAlert("画像ファイルを選択してください (JPEG, PNG, GIF, WebPなど)");
                     return;
                 }
                 try {
                     uiUtils.revokeExistingObjectUrl(); // 既存URLを破棄
                     const blob = file; // ファイルはBlobとして扱える
                     // DBにBlobとして保存
                     await dbUtils.saveSetting('backgroundImageBlob', blob);
                     state.settings.backgroundImageBlob = blob; // stateにも反映
                     // 新しいオブジェクトURLを作成して適用
                     state.backgroundImageUrl = URL.createObjectURL(blob);
                     document.documentElement.style.setProperty('--chat-background-image', `url(${state.backgroundImageUrl})`);
                     uiUtils.updateBackgroundSettingsUI(); // UI更新
                     console.log("背景画像を更新しました。");
                     // アラートは不要 (変更は即時反映、DB保存は「設定を保存」で行う)
                 } catch (error) {
                     console.error("背景画像アップロード処理エラー:", error);
                     await uiUtils.showCustomAlert(`背景画像の処理中にエラーが発生しました: ${error}`);
                     // エラー時はリセット
                     uiUtils.revokeExistingObjectUrl();
                     document.documentElement.style.setProperty('--chat-background-image', 'none');
                     state.settings.backgroundImageBlob = null;
                     uiUtils.updateBackgroundSettingsUI();
                 }
             },
             // 背景画像削除の確認
             async confirmDeleteBackgroundImage() {
                 const confirmed = await uiUtils.showCustomConfirm("背景画像を削除しますか？");
                 if (confirmed) {
                     await this.handleBackgroundImageDelete();
                 }
             },
             // 背景画像削除処理
             async handleBackgroundImageDelete() {
                 try {
                     uiUtils.revokeExistingObjectUrl(); // URL破棄
                     // DBの値をnullで上書き
                     await dbUtils.saveSetting('backgroundImageBlob', null);
                     state.settings.backgroundImageBlob = null; // stateもnullに
                     // スタイルとUIをリセット
                     document.documentElement.style.setProperty('--chat-background-image', 'none');
                     uiUtils.updateBackgroundSettingsUI();
                     console.log("背景画像を削除しました。");
                     // アラート不要
                 } catch (error) {
                     console.error("背景画像削除エラー:", error);
                     await uiUtils.showCustomAlert(`背景画像の削除中にエラーが発生しました: ${error}`);
                 }
             },
             // -------------------------------

            // 設定を保存
            async saveSettings() {
                 // UIから値を取得 (背景Blobは別途処理済みなので除く)
                 const newSettings = {
                     apiKey: elements.apiKeyInput.value.trim(),
                     modelName: elements.modelNameSelect.value,
                     streamingOutput: elements.streamingOutputCheckbox.checked,
                     streamingSpeed: elements.streamingSpeedInput.value === '' ? DEFAULT_STREAMING_SPEED : parseInt(elements.streamingSpeedInput.value),
                     systemPrompt: elements.systemPromptDefaultTextarea.value.trim(), // デフォルト用
                     temperature: elements.temperatureInput.value === '' ? null : parseFloat(elements.temperatureInput.value),
                     maxTokens: elements.maxTokensInput.value === '' ? null : parseInt(elements.maxTokensInput.value),
                     topK: elements.topKInput.value === '' ? null : parseInt(elements.topKInput.value),
                     topP: elements.topPInput.value === '' ? null : parseFloat(elements.topPInput.value),
                     dummyUser: elements.dummyUserInput.value.trim(),
                     dummyModel: elements.dummyModelInput.value.trim(),
                     concatDummyModel: elements.concatDummyModelCheckbox.checked,
                     additionalModels: elements.additionalModelsTextarea.value.trim(),
                     pseudoStreaming: elements.pseudoStreamingCheckbox.checked,
                     enterToSend: elements.enterToSendCheckbox.checked,
                     historySortOrder: elements.historySortOrderSelect.value,
                     darkMode: elements.darkModeToggle.checked,
                     fontFamily: elements.fontFamilyInput.value.trim(), // フォント設定を取得
                     hideSystemPromptInChat: elements.hideSystemPromptToggle.checked, // SP非表示設定
                 };

                 // --- 数値入力のバリデーション ---
                 if (isNaN(newSettings.streamingSpeed) || newSettings.streamingSpeed < 0) {
                     newSettings.streamingSpeed = DEFAULT_STREAMING_SPEED;
                 }
                 if (newSettings.temperature !== null && (isNaN(newSettings.temperature) || newSettings.temperature < 0 || newSettings.temperature > 2)) {
                     newSettings.temperature = null; // 不正値はnull (APIデフォルト) に
                 }
                 if (newSettings.maxTokens !== null && (isNaN(newSettings.maxTokens) || newSettings.maxTokens < 1)) {
                     newSettings.maxTokens = null;
                 }
                 if (newSettings.topK !== null && (isNaN(newSettings.topK) || newSettings.topK < 1)) {
                     newSettings.topK = null;
                 }
                 if (newSettings.topP !== null && (isNaN(newSettings.topP) || newSettings.topP < 0 || newSettings.topP > 1)) {
                     newSettings.topP = null;
                 }
                 // --- バリデーション終了 ---

                 try {
                     const oldSortOrder = state.settings.historySortOrder; // 更新前のソート順を保持

                     // 各設定をDBに保存 (背景Blobは除く)
                     const promises = Object.entries(newSettings).map(([key, value]) =>
                         dbUtils.saveSetting(key, value)
                     );
                     await Promise.all(promises);

                     // stateをバリデーション後の値で更新 (背景Blobは既にstateにある)
                     state.settings = { ...state.settings, ...newSettings };

                     // 全設定をUIに再適用 (バリデーションで修正された値も反映)
                     uiUtils.applySettingsToUI();
                     // applyDarkMode, applyFontFamily, toggleSystemPromptVisibility は applySettingsToUI内で呼ばれる

                     console.log("設定保存成功:", { ...state.settings, backgroundImageBlob: state.settings.backgroundImageBlob ? '[Blob]' : null });
                     await uiUtils.showCustomAlert("設定を保存しました。");

                     // ソート順が変更され、履歴画面が表示中ならリストを再描画
                     if (newSettings.historySortOrder !== oldSortOrder && state.currentScreen === 'history') {
                         uiUtils.renderHistoryList();
                     }
                 } catch (error) {
                     await uiUtils.showCustomAlert(`設定の保存中にエラーが発生しました: ${error}`);
                 }
            },

            // アプリを更新 (キャッシュクリア)
            async updateApp() {
                // Service Workerが利用可能かチェック
                if (!navigator.serviceWorker || !navigator.serviceWorker.controller) {
                    await uiUtils.showCustomAlert("Service Workerが検出されませんでした。ページをリロードしてから再試行してください。");
                    return;
                }
                const confirmed = await uiUtils.showCustomConfirm("アプリのキャッシュをクリアして最新版を再取得しますか？ (ページがリロードされます)");
                if (confirmed) {
                    // Service Workerにキャッシュクリアメッセージを送信
                    navigator.serviceWorker.ready.then(reg => {
                        if (reg.active) {
                            reg.active.postMessage({ action: 'clearCache' });
                            // リロードはService Workerからの応答メッセージで行う
                        } else {
                            uiUtils.showCustomAlert("アクティブなService Workerが見つかりません。手動でリロードが必要かもしれません。");
                        }
                    }).catch(async err => {
                        await uiUtils.showCustomAlert("Service Workerの準備中にエラーが発生しました。");
                    });
                }
            },

            // 全データ削除の確認と実行
            async confirmClearAllData() {
                const confirmed = await uiUtils.showCustomConfirm("本当にすべてのデータ（チャット履歴と設定）を削除しますか？この操作は元に戻せません。");
                if (confirmed) {
                    try {
                        uiUtils.revokeExistingObjectUrl(); // 背景画像のURLを破棄
                        await dbUtils.clearAllData(); // DBの全データをクリア
                        await uiUtils.showCustomAlert("すべてのデータが削除されました。アプリをリセットします。");

                        // stateを完全に初期デフォルト状態にリセット
                        state.currentChatId = null;
                        state.currentMessages = [];
                        state.currentSystemPrompt = ''; // システムプロンプトもリセット
                        state.settings = { // 初期デフォルト値に戻す
                            apiKey: '',
                            modelName: DEFAULT_MODEL,
                            streamingOutput: true,
                            streamingSpeed: DEFAULT_STREAMING_SPEED,
                            systemPrompt: '', // デフォルトSPもリセット
                            temperature: null,
                            maxTokens: null,
                            topK: null,
                            topP: null,
                            dummyUser: '',
                            dummyModel: '',
                            concatDummyModel: false,
                            additionalModels: '',
                            pseudoStreaming: false,
                            enterToSend: true,
                            historySortOrder: 'updatedAt',
                            // ダークモードはOS設定にフォールバック
                            darkMode: window.matchMedia?.('(prefers-color-scheme: dark)').matches ?? false,
                            backgroundImageBlob: null,
                            fontFamily: '', // フォントもリセット
                            hideSystemPromptInChat: false, // SP非表示もリセット
                        };
                        state.backgroundImageUrl = null;

                        // リセットされた状態をUIに適用
                        document.documentElement.style.setProperty('--chat-background-image', 'none'); // 背景スタイルリセット
                        uiUtils.applySettingsToUI(); // 設定UIをリセット (ダークモード、背景UI、フォント、SP表示含む)
                        this.startNewChat(); // 新規チャット状態にする (履歴状態もリセットされる)
                        uiUtils.showScreen('chat', true); // popstate経由ではないが履歴操作はstartNewChatに任せる
                    } catch (error) {
                        await uiUtils.showCustomAlert(`データ削除中にエラーが発生しました: ${error}`);
                    }
                }
            },

            // --- システムプロンプト編集 ---
            startEditSystemPrompt() {
                if (state.isSending) return; // 送信中は編集不可
                state.isEditingSystemPrompt = true;
                elements.systemPromptEditor.value = state.currentSystemPrompt; // 現在の値で初期化
                uiUtils.adjustTextareaHeight(elements.systemPromptEditor, 200);
                elements.systemPromptEditor.focus();
                console.log("システムプロンプト編集開始");
            },
            async saveCurrentSystemPrompt() {
                const newPrompt = elements.systemPromptEditor.value.trim();
                if (newPrompt !== state.currentSystemPrompt) {
                    state.currentSystemPrompt = newPrompt;
                    try {
                        await dbUtils.saveChat(); // 現在のチャットを保存 (SP含む)
                        console.log("システムプロンプト保存完了");
                    } catch (error) {
                        await uiUtils.showCustomAlert("システムプロンプトの保存に失敗しました。");
                        // エラー時は元の値に戻す？ UIはそのままにする？ -> UIはそのまま
                    }
                }
                state.isEditingSystemPrompt = false;
                elements.systemPromptDetails.removeAttribute('open'); // detailsを閉じる
            },
            cancelEditSystemPrompt() {
                state.isEditingSystemPrompt = false;
                elements.systemPromptEditor.value = state.currentSystemPrompt; // 元の値に戻す
                elements.systemPromptDetails.removeAttribute('open'); // detailsを閉じる
                uiUtils.adjustTextareaHeight(elements.systemPromptEditor, 200);
                console.log("システムプロンプト編集キャンセル");
            },
            // -----------------------------

            // --- メッセージアクション ---
            // メッセージ編集開始
            async startEditMessage(index, messageElement) {
                 // 送信中は編集不可
                 if (state.isSending) {
                     await uiUtils.showCustomAlert("送信中は編集できません。");
                     return;
                 }
                 // 他のメッセージを編集中なら警告
                 if (state.editingMessageIndex !== null && state.editingMessageIndex !== index) {
                     await uiUtils.showCustomAlert("他のメッセージを編集中です。");
                     return;
                 }
                 // システムプロンプト編集中なら警告
                 if (state.isEditingSystemPrompt) {
                     await uiUtils.showCustomAlert("システムプロンプトを編集中です。");
                     return;
                 }
                 // すでに編集中ならフォーカスするだけ
                 if (state.editingMessageIndex === index) {
                     messageElement.querySelector('.edit-textarea')?.focus();
                     return;
                 }

                 const message = state.currentMessages[index];
                 if (!message) return; // メッセージデータがない場合は中断

                 const rawContent = message.content; // 元のテキスト
                 state.editingMessageIndex = index; // 編集中インデックスを設定

                 const contentDiv = messageElement.querySelector('.message-content');
                 const editArea = messageElement.querySelector('.message-edit-area');
                 const cascadeControls = messageElement.querySelector('.message-cascade-controls'); // 上部コントロール
                 editArea.innerHTML = ''; // 編集エリアをクリア

                 let horizontalPadding = 0;
                 try {// パディング計算
                     const computedStyle = window.getComputedStyle(messageElement);
                     const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;
                     const paddingRight = parseFloat(computedStyle.paddingRight) || 0;
                     horizontalPadding = paddingLeft + paddingRight;
                 } catch (e) {
                     console.error("幅の動的計算中にエラー:", e);
                 }
                 messageElement.style.width = `calc(var(--message-max-width) + ${horizontalPadding}px + 17px)`/*17pxは決め打ち。対処療法*/;

                 // テキストエリア作成
                 const textarea = document.createElement('textarea');
                 textarea.value = rawContent;
                 textarea.classList.add('edit-textarea');
                 textarea.rows = 3; // 初期行数
                 textarea.oninput = () => uiUtils.adjustTextareaHeight(textarea, 400); // 入力で高さ調整 (最大400px)

                 // アクションボタンエリア作成
                 const actionsDiv = document.createElement('div');
                 actionsDiv.classList.add('message-edit-actions');

                 // 保存ボタン
                 const saveButton = document.createElement('button');
                 saveButton.textContent = '保存';
                 saveButton.classList.add('save-edit-btn');
                 saveButton.onclick = () => this.saveEditMessage(index, messageElement);

                 // キャンセルボタン
                 const cancelButton = document.createElement('button');
                 cancelButton.textContent = 'キャンセル';
                 cancelButton.classList.add('cancel-edit-btn');
                 cancelButton.onclick = () => this.cancelEditMessage(index, messageElement);

                 actionsDiv.appendChild(saveButton);
                 actionsDiv.appendChild(cancelButton);
                 editArea.appendChild(textarea);
                 editArea.appendChild(actionsDiv);

                 // UI切り替え
                 messageElement.classList.add('editing'); // 編集中クラス追加
                 if(contentDiv) contentDiv.classList.add('hidden'); // 元のコンテンツ非表示
                 if(cascadeControls) cascadeControls.classList.add('hidden'); // 上部コントロール非表示
                 editArea.classList.remove('hidden'); // 編集エリア表示

                 // 初期高さ調整とフォーカス
                 uiUtils.adjustTextareaHeight(textarea, 400);
                 textarea.focus();
                 textarea.select(); // テキスト全選択
            },

            // メッセージ編集を保存
            async saveEditMessage(index, messageElement) {
                const textarea = messageElement.querySelector('.edit-textarea');
                if (!textarea) { // テキストエリアが見つからない場合はキャンセル扱い
                    this.cancelEditMessage(index, messageElement);
                    return;
                }
                const newRawContent = textarea.value.trim(); // 新しいテキスト (前後の空白除去)
                const originalMessage = state.currentMessages[index];

                // 内容に変更がない場合はキャンセルと同じ動作
                if (newRawContent === originalMessage.content) {
                    this.cancelEditMessage(index, messageElement);
                    return;
                }

                // stateのメッセージ内容を更新
                originalMessage.content = newRawContent;
                originalMessage.timestamp = Date.now(); // 更新日時を更新
                delete originalMessage.error; // エラーフラグがあれば削除

                // UIのメッセージ内容を更新
                const contentDiv = messageElement.querySelector('.message-content');
                if(contentDiv && typeof marked !== 'undefined' && originalMessage.role === 'model') { // モデルメッセージのみMarkdown
                    try {
                        contentDiv.innerHTML = marked.parse(newRawContent || ''); // Markdownパース
                    } catch (e) {
                        console.error("編集保存時のMarkdownパースエラー:", e);
                        contentDiv.textContent = newRawContent; // エラー時はテキスト表示
                    }
                } else if (contentDiv) { // ユーザーメッセージ or markedなし
                    const pre = contentDiv.querySelector('pre') || document.createElement('pre');
                    pre.textContent = newRawContent;
                    if(!contentDiv.querySelector('pre')) {
                        contentDiv.innerHTML = ''; // 既存内容をクリア
                        contentDiv.appendChild(pre);
                    }
                }

                this.finishEditing(messageElement); // 編集UIを終了

                // 最初のユーザーメッセージが編集された場合、タイトル更新が必要かチェック
                let requiresTitleUpdate = (index === state.currentMessages.findIndex(m => m.role === 'user'));
                try {
                    // タイトル更新が必要なら新しいタイトルを生成して保存
                    let newTitleForSave = null;
                    if (requiresTitleUpdate) {
                        newTitleForSave = newRawContent.substring(0, 50) || "無題のチャット"; // SPは参照しない
                    }
                    await dbUtils.saveChat(newTitleForSave);
                    // UIのタイトルも更新
                    if (requiresTitleUpdate) {
                        uiUtils.updateChatTitle(newTitleForSave);
                    }
                    console.log("メッセージ編集後にチャット保存:", index);
                } catch (error) {
                    await uiUtils.showCustomAlert("メッセージ編集後のチャット保存に失敗しました。");
                }
            },
            // メッセージ編集をキャンセル
            cancelEditMessage(index, messageElement = null) {
                  // 要素が渡されていない場合は検索
                  if (!messageElement) {
                      messageElement = elements.messageContainer.querySelector(`.message[data-index="${index}"]`);
                  }
                  if (messageElement) {
                      this.finishEditing(messageElement); // 編集UIを終了
                  } else if (state.editingMessageIndex === index) {
                      // 要素が見つからなくても、編集中インデックスが一致すればリセット
                      state.editingMessageIndex = null;
                      console.log("編集キャンセル: 要素が見つかりませんでしたがインデックスをリセット:", index);
                  }
            },
            // 編集UIを終了する共通処理
            finishEditing(messageElement) {
                if (!messageElement) return;
                const editArea = messageElement.querySelector('.message-edit-area');
                const contentDiv = messageElement.querySelector('.message-content');
                const cascadeControls = messageElement.querySelector('.message-cascade-controls'); // 上部コントロール
                const textarea = messageElement.querySelector('.edit-textarea');

                messageElement.style.removeProperty('width');

                messageElement.classList.remove('editing'); // 編集中クラス削除
                if(contentDiv) contentDiv.classList.remove('hidden'); // 元のコンテンツ表示
                if(cascadeControls) cascadeControls.classList.remove('hidden'); // 上部コントロール再表示
                if(editArea) { // 編集エリアを非表示にして内容クリア
                    editArea.classList.add('hidden');
                    editArea.innerHTML = '';
                }

                // 編集中インデックスをリセット
                const index = parseInt(messageElement.dataset.index, 10);
                if (state.editingMessageIndex === index) {
                    state.editingMessageIndex = null;
                    console.log("編集終了:", index);
                }
            },

            // メッセージを削除 (会話ターン全体)
            async deleteMessage(index) {
                // 編集中、送信中、システムプロンプト編集中は削除不可 (既存のチェック)
                if (state.editingMessageIndex === index) {
                    this.cancelEditMessage(index);
                }
                if (state.isSending) {
                    await uiUtils.showCustomAlert("送信中は削除できません。");
                    return;
                }
                if (state.isEditingSystemPrompt) {
                    await uiUtils.showCustomAlert("システムプロンプト編集中は削除できません。");
                    return;
                }
                if (index < 0 || index >= state.currentMessages.length) {
                     console.error("削除対象のインデックスが無効:", index);
                     return;
                }

                const messageToDelete = state.currentMessages[index];
                const messageContentPreview = messageToDelete.content.substring(0, 30) + "...";
                let confirmMessage = "";
                let deleteTargetDescription = ""; // 削除対象の説明（ログ用）
                let indicesToDelete = []; // 削除対象のインデックスリスト

                // --- 削除範囲と確認メッセージを決定 ---
                if (messageToDelete.role === 'model' && messageToDelete.isCascaded && messageToDelete.siblingGroupId) {
                    // **ケース1: カスケードモデル応答グループ全体**
                    const groupId = messageToDelete.siblingGroupId;
                    const siblings = state.currentMessages.filter(msg => msg.role === 'model' && msg.isCascaded && msg.siblingGroupId === groupId);
                    indicesToDelete = state.currentMessages
                        .map((msg, i) => (msg.role === 'model' && msg.isCascaded && msg.siblingGroupId === groupId) ? i : -1)
                        .filter(i => i !== -1);

                    confirmMessage = `「${messageContentPreview}」を含む応答グループ全体 (${siblings.length}件) を削除しますか？`;
                    deleteTargetDescription = `カスケードグループ (gid: ${groupId}, ${indicesToDelete.length}件)`;
                } else {
                    // **ケース2: 単一メッセージ (ユーザー入力 or 非カスケードモデル応答)**
                    indicesToDelete.push(index);
                    confirmMessage = `メッセージ「${messageContentPreview}」(${messageToDelete.role}) を削除しますか？`;
                    deleteTargetDescription = `単一メッセージ (index: ${index}, role: ${messageToDelete.role})`;
                }

                // --- 削除実行 ---
                const confirmed = await uiUtils.showCustomConfirm(confirmMessage);
                if (confirmed) {
                    console.log(`削除実行: ${deleteTargetDescription}`);
                    const originalFirstUserMsgIndex = state.currentMessages.findIndex(m => m.role === 'user');

                    // stateからメッセージを削除 (インデックスが大きい方から削除してズレを防ぐ)
                    indicesToDelete.sort((a, b) => b - a).forEach(idx => {
                        state.currentMessages.splice(idx, 1);
                    });
                    console.log(`メッセージ削除完了 (state)。削除件数: ${indicesToDelete.length}`);

                    // --- UI再描画 ---
                    uiUtils.renderChatMessages();
                    // カスケードグループ削除後は操作ボックスの再表示は不要

                    // --- タイトル更新とDB保存 ---
                    const newFirstUserMsgIndex = state.currentMessages.findIndex(m => m.role === 'user');
                    // タイトル更新が必要か判断 (元の最初のユーザーメッセージが削除範囲に含まれていた場合)
                    let requiresTitleUpdate = indicesToDelete.includes(originalFirstUserMsgIndex);

                    try {
                        let newTitleForSave = null;
                        const currentChatData = state.currentChatId ? await dbUtils.getChat(state.currentChatId) : null;

                        if (requiresTitleUpdate) {
                            const newFirstUserMessage = newFirstUserMsgIndex !== -1 ? state.currentMessages[newFirstUserMsgIndex] : null;
                            newTitleForSave = newFirstUserMessage ? newFirstUserMessage.content.substring(0, 50) : "無題のチャット";
                        } else if (currentChatData) {
                            newTitleForSave = currentChatData.title;
                        }

                        await dbUtils.saveChat(newTitleForSave);

                        if (requiresTitleUpdate) {
                            uiUtils.updateChatTitle(newTitleForSave);
                        }

                        if (state.currentMessages.length === 0 && !state.currentSystemPrompt && state.currentChatId) {
                            console.log("チャットが空になったためリセットします。");
                            this.startNewChat();
                        }
                    } catch (error) {
                        console.error("メッセージ削除後のチャット保存/取得エラー:", error);
                        await uiUtils.showCustomAlert("メッセージ削除後のチャット保存に失敗しました。");
                    }
                } else {
                     console.log("削除キャンセル");
                }
            },

            
            // 指定メッセージからリトライ
            async retryFromMessage(index) {
                // 編集中は不可
                if (state.editingMessageIndex !== null) {
                    await uiUtils.showCustomAlert("編集中はリトライできません。");
                    return;
                }
                // 送信中は不可
                if (state.isSending) {
                    await uiUtils.showCustomAlert("送信中です。");
                    return;
                }
                // システムプロンプト編集中は不可
                if (state.isEditingSystemPrompt) {
                    await uiUtils.showCustomAlert("システムプロンプト編集中はリトライできません。");
                    return;
                }
                const userMessage = state.currentMessages[index];
                // ユーザーメッセージ以外からはリトライ不可
                if (!userMessage || userMessage.role !== 'user') return;

                // リトライ確認 (メッセージ修正)
                const messageContentPreview = userMessage.content.substring(0, 30) + "...";
                const confirmed = await uiUtils.showCustomConfirm(`「${messageContentPreview}」から再生成しますか？\n(この入力に対する既存の応答は保持されますが、**これより未来の会話履歴は削除されます**)`);

                if (confirmed) {
                    console.log(`リトライ開始: index=${index}`);

                    // --- 後続の不要な履歴を削除する処理 ---
                    let deleteStartIndex = -1;
                    let scanIndex = index + 1; // リトライ対象ユーザーメッセージの次から開始

                    // 保持すべきモデル応答群の siblingGroupId を特定
                    let targetSiblingGroupId = null;
                    if (scanIndex < state.currentMessages.length && state.currentMessages[scanIndex].role === 'model') {
                        // 最初のモデル応答が存在する場合、その siblingGroupId を取得
                        targetSiblingGroupId = state.currentMessages[scanIndex].siblingGroupId || null; // groupId がない場合は null
                        console.log(`保持対象の siblingGroupId: ${targetSiblingGroupId}`);
                    }

                    // targetSiblingGroupId に一致するモデル応答群をスキップ
                    if (targetSiblingGroupId !== null) { // siblingGroupId がある場合
                        while (
                            scanIndex < state.currentMessages.length &&
                            state.currentMessages[scanIndex].role === 'model' &&
                            state.currentMessages[scanIndex].siblingGroupId === targetSiblingGroupId
                        ) {
                            scanIndex++;
                        }
                    } else { // 最初のモデル応答に siblingGroupId がない場合 (isCascaded=false など)
                         if (scanIndex < state.currentMessages.length && state.currentMessages[scanIndex].role === 'model') {
                            // 最初のモデル応答のみスキップ (グループ化されていない)
                            scanIndex++;
                        }
                         // それ以降は siblingGroupId が一致しないのでループに入らない
                    }
                    // scanIndex は、保持すべきモデル応答群の次のインデックス、または配列の終端を指す

                    // 削除開始インデックスを決定
                    if (scanIndex < state.currentMessages.length) {
                        // 配列の終端でなければ、scanIndex が削除開始位置
                        deleteStartIndex = scanIndex;
                    }
                    // scanIndex が配列の終端なら deleteStartIndex は -1 のまま (削除不要)

                    if (deleteStartIndex !== -1) {
                        const deletedCount = state.currentMessages.length - deleteStartIndex;
                        console.log(`インデックス ${deleteStartIndex} 以降の ${deletedCount} 件の履歴を削除します。`);
                        state.currentMessages.splice(deleteStartIndex); // deleteStartIndex 以降をすべて削除
                    } else {
                        console.log("削除対象となる未来の会話履歴はありませんでした。");
                    }
                    // --- 削除処理ここまで ---

                    // UIを更新 (削除された状態を表示)
                    uiUtils.renderChatMessages();
                    uiUtils.scrollToBottom(); // 削除後の表示位置にスクロール
                    
                    // --- 既存の応答を一時的に非表示にする処理 ---
                    const elementsToHide = []; // 非表示にしたDOM要素を保持する配列
                    const messageContainer = elements.messageContainer; // パフォーマンスのためキャッシュ

                    // targetSiblingGroupId が存在する場合、そのグループ全体を非表示
                    if (targetSiblingGroupId) {
                        messageContainer.querySelectorAll(`.message.model[data-index]`).forEach(el => {
                            const msgIndex = parseInt(el.dataset.index, 10);
                            const potentialMsg = state.currentMessages[msgIndex]; // 削除後のインデックスでアクセス試行
                            if (potentialMsg && potentialMsg.role === 'model' && potentialMsg.siblingGroupId === targetSiblingGroupId) {
                                 el.classList.add('retrying-hidden');
                                 elementsToHide.push(el);
                            }
                        });
                         console.log(`${elementsToHide.length}件の既存応答 (グループ ${targetSiblingGroupId}) を一時的に非表示にしました。`);
                    } else if (index + 1 < state.currentMessages.length && state.currentMessages[index + 1]?.role === 'model') {
                        // 非カスケードの単一応答を非表示（削除後のインデックス index + 1 がモデル応答の場合）
                        const element = messageContainer.querySelector(`.message.model[data-index="${index + 1}"]`);
                        if (element) {
                            element.classList.add('retrying-hidden');
                            elementsToHide.push(element);
                            console.log(`1件の既存応答 (非カスケード, 削除後のindex: ${index + 1}) を一時的に非表示にしました。`);
                        }
                    }
                    // ---------------------------------------------

                    // APIに送信するメッセージリストを作成 (削除後の state から)
                    // リトライ対象のユーザーメッセージ (index) までを含める
                    const messagesForApi = state.currentMessages.slice(0, index + 1);

                    // handleSend をリトライモードで呼び出す
                    await this.handleSend(true, messagesForApi);
                }
            },

            // --- カスケード応答操作 ---
            // 指定インデックスのメッセージの兄弟カスケード応答を取得
            getCascadedSiblings(index, includeSelf = false) {
                const targetMsg = state.currentMessages[index];
                if (!targetMsg || !targetMsg.isCascaded || !targetMsg.siblingGroupId) {
                    return [];
                }
                const groupId = targetMsg.siblingGroupId;
                const siblings = state.currentMessages.filter((msg, i) =>
                    msg.role === 'model' &&
                    msg.isCascaded &&
                    msg.siblingGroupId === groupId &&
                    (includeSelf || i !== index) // includeSelfがtrueなら自分自身も含む
                );
                return siblings;
            },

            // カスケード応答をナビゲート (前へ/次へ)
            async navigateCascade(currentIndex, direction) {
                const currentMsg = state.currentMessages[currentIndex];
                if (!currentMsg || !currentMsg.isCascaded || !currentMsg.siblingGroupId) return;

                const groupId = currentMsg.siblingGroupId;
                // 同じグループの兄弟を state.currentMessages 内の元の順序で取得
                const siblingsWithIndices = state.currentMessages
                    .map((msg, i) => ({ msg, originalIndex: i })) // 元のインデックスを保持
                    .filter(item => item.msg.role === 'model' && item.msg.isCascaded && item.msg.siblingGroupId === groupId);

                // 現在表示中のメッセージが兄弟リストの何番目か特定
                const currentSiblingIndex = siblingsWithIndices.findIndex(item => item.originalIndex === currentIndex);
                if (currentSiblingIndex === -1) return; // 見つからない場合は中断

                let targetSiblingIndex = -1;
                if (direction === 'prev' && currentSiblingIndex > 0) {
                    targetSiblingIndex = currentSiblingIndex - 1;
                } else if (direction === 'next' && currentSiblingIndex < siblingsWithIndices.length - 1) {
                    targetSiblingIndex = currentSiblingIndex + 1;
                }

                if (targetSiblingIndex !== -1) {
                    // isSelected フラグを更新
                    currentMsg.isSelected = false;
                    const newlySelectedMessage = siblingsWithIndices[targetSiblingIndex].msg; // 新しく選択されたメッセージオブジェクト
                    newlySelectedMessage.isSelected = true;
                    const newlySelectedIndex = siblingsWithIndices[targetSiblingIndex].originalIndex; // 新しく選択されたメッセージの元のインデックス

                    console.log(`カスケードナビゲーション: ${currentSiblingIndex + 1}/${siblingsWithIndices.length} -> ${targetSiblingIndex + 1}/${siblingsWithIndices.length}`);

                    // UIを再描画
                    uiUtils.renderChatMessages();

                    // 再描画後に .show-actions クラスを再付与
                    requestAnimationFrame(() => { // DOM更新が完了するのを待つ
                        const newlySelectedElement = elements.messageContainer.querySelector(`.message[data-index="${newlySelectedIndex}"]`);
                        if (newlySelectedElement && !newlySelectedElement.classList.contains('editing')) {
                             // 他に表示されているものがあれば消す
                             const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                             if (currentlyShown && currentlyShown !== newlySelectedElement) {
                                 currentlyShown.classList.remove('show-actions');
                             }
                             // 新しい要素にクラスを付与
                             newlySelectedElement.classList.add('show-actions');
                             console.log(`.show-actions を再付与: index=${newlySelectedIndex}`);
                        }
                    });

                    // DBに保存
                    try {
                        await dbUtils.saveChat();
                    } catch (error) {
                        console.error("カスケードナビゲーション後の保存失敗:", error);
                        await uiUtils.showCustomAlert("応答の切り替え状態の保存に失敗しました。");
                    }
                }
            },

            // 特定のカスケード応答削除の確認
            async confirmDeleteCascadeResponse(indexToDelete) {
                const msgToDelete = state.currentMessages[indexToDelete];
                // 対象がカスケード応答でない場合は処理しない
                if (!msgToDelete || msgToDelete.role !== 'model' || !msgToDelete.isCascaded || !msgToDelete.siblingGroupId) {
                    console.warn("confirmDeleteCascadeResponse: 対象はカスケード応答ではありません。", indexToDelete);
                    return;
                }
                // 編集中、送信中、SP編集中は不可
                if (state.editingMessageIndex !== null) { await uiUtils.showCustomAlert("編集中は削除できません。"); return; }
                if (state.isSending) { await uiUtils.showCustomAlert("送信中は削除できません。"); return; }
                if (state.isEditingSystemPrompt) { await uiUtils.showCustomAlert("システムプロンプト編集中は削除できません。"); return; }

                // 削除確認
                const siblings = this.getCascadedSiblings(indexToDelete, true); // 自分自身を含む
                const currentIndexInGroup = siblings.findIndex(m => m === msgToDelete) + 1;
                const totalSiblings = siblings.length;
                const contentPreview = msgToDelete.content.substring(0, 30) + "...";
                const confirmMsg = `この応答 (${currentIndexInGroup}/${totalSiblings})「${contentPreview}」を削除しますか？\n(この応答のみが削除されます)`;

                const confirmed = await uiUtils.showCustomConfirm(confirmMsg);
                if (confirmed) {
                    const wasSelected = msgToDelete.isSelected;
                    const groupId = msgToDelete.siblingGroupId;

                    // --- stateから単一メッセージ削除 ---
                    state.currentMessages.splice(indexToDelete, 1);
                    console.log(`カスケード応答削除 (単一): index=${indexToDelete}, groupId=${groupId}`);

                    // --- isSelected 調整 ---
                    let newlySelectedIndex = -1; // 削除後に選択状態になるべきメッセージのインデックス
                    const remainingSiblingsWithIndices = state.currentMessages
                        .map((msg, i) => ({ msg, originalIndex: i }))
                        .filter(item => item.msg.role === 'model' && item.msg.isCascaded && item.msg.siblingGroupId === groupId);

                    if (remainingSiblingsWithIndices.length > 0) {
                        if (wasSelected) {
                            // 削除されたのが選択中だった場合、残りの最後のものを選択状態にする
                            const lastSiblingItem = remainingSiblingsWithIndices[remainingSiblingsWithIndices.length - 1];
                            if (!lastSiblingItem.msg.isSelected) {
                                lastSiblingItem.msg.isSelected = true;
                                newlySelectedIndex = lastSiblingItem.originalIndex;
                                console.log(`削除後、新しい選択応答を設定 (単一カスケード): newIndex=${newlySelectedIndex}`);
                            } else {
                                newlySelectedIndex = lastSiblingItem.originalIndex; // すでに選択済みだった場合もインデックス記録
                            }
                        } else {
                             // 削除されたのが非選択だった場合、依然として選択中のものを探す
                             const stillSelectedItem = remainingSiblingsWithIndices.find(item => item.msg.isSelected);
                             if (stillSelectedItem) {
                                 newlySelectedIndex = stillSelectedItem.originalIndex;
                             }
                        }
                    } else {
                        console.log(`グループ ${groupId} の最後の応答が削除されました。`);
                    }

                    // --- UI再描画 & 操作ボックス再表示 ---
                    uiUtils.renderChatMessages();
                    requestAnimationFrame(() => {
                         if (newlySelectedIndex !== -1) {
                             const elementToShowActions = elements.messageContainer.querySelector(`.message[data-index="${newlySelectedIndex}"]`);
                             if (elementToShowActions && !elementToShowActions.classList.contains('editing')) {
                                  const currentlyShown = elements.messageContainer.querySelector('.message.show-actions');
                                  if (currentlyShown && currentlyShown !== elementToShowActions) {
                                      currentlyShown.classList.remove('show-actions');
                                  }
                                  elementToShowActions.classList.add('show-actions');
                                  console.log(`.show-actions を再付与 (単一カスケード削除後): index=${newlySelectedIndex}`);
                             }
                         }
                    });

                    // --- DB保存 ---
                    try {
                        await dbUtils.saveChat(); // isSelectedの変更などを保存
                    } catch (error) {
                        console.error("単一カスケード応答削除後の保存失敗:", error);
                        await uiUtils.showCustomAlert("応答削除後のチャット状態の保存に失敗しました。");
                    }
                } else {
                     console.log("単一カスケード応答の削除キャンセル");
                }
            }

        }; // appLogic終了

        // --- 初期化処理 ---
        appLogic.initializeApp();
    </script>
</body>
</html>